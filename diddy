local MacLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/AlphaTwoScripts/BOOMA/refs/heads/main/LunarZ-UI"))()

-- Detect if user is on mobile
local UserInputService = game:GetService("UserInputService")
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Set window size based on device
local windowSize
if isMobile then
    windowSize = UDim2.fromOffset(570, 360)  -- Mobile size
else
    windowSize = UDim2.fromOffset(790, 640)  -- PC size
end

local Window = MacLib:Window({
	Title = "LunarZ",
	Subtitle = "AOT:R | FREE",
	Size = windowSize,
	DragStyle = 1,
	DisabledWindowControls = {},
	ShowUserInfo = true,
	Keybind = Enum.KeyCode.RightControl,
	AcrylicBlur = true,
})

local globalSettings = {
	UIBlurToggle = Window:GlobalSetting({
		Name = "UI Blur",
		Default = Window:GetAcrylicBlurState(),
		Callback = function(bool)
			Window:SetAcrylicBlurState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
				Lifetime = 5
			})
		end,
	}),
	NotificationToggler = Window:GlobalSetting({
		Name = "Notifications",
		Default = Window:GetNotificationsState(),
		Callback = function(bool)
			Window:SetNotificationsState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " Notifications",
				Lifetime = 5
			})
		end,
	}),
	ShowUserInfo = Window:GlobalSetting({
		Name = "Show User Info",
		Default = Window:GetUserInfoState(),
		Callback = function(bool)
			Window:SetUserInfoState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Showing" or "Redacted") .. " User Info",
				Lifetime = 5
			})
		end,
	})
}

local tabGroups = {
	TabGroup1 = Window:TabGroup()
}

local tabs = {
	Main = tabGroups.TabGroup1:Tab({ Name = "Main", Image = "rbxassetid://86591853167234" }),
	Raids = tabGroups.TabGroup1:Tab({ Name = "Raids", Image = "rbxassetid://115443066665979" }),
	Stats = tabGroups.TabGroup1:Tab({ Name = "Stats", Image = "rbxassetid://95014688478272" }),
	Webhook = tabGroups.TabGroup1:Tab({ Name = "Webhook", Image = "rbxassetid://70774834798137" }),
	Visual = tabGroups.TabGroup1:Tab({ Name = "Visual", Image = "rbxassetid://100148515061030" }),
	Teleport = tabGroups.TabGroup1:Tab({ Name = "Teleport", Image = "rbxassetid://6723742952" }),
	Settings = tabGroups.TabGroup1:Tab({ Name = "Settings", Image = "rbxassetid://10734950309" }),
}

local sections = {
	MainSection1 = tabs.Main:Section({ Side = "Left" }),
	MainSection2 = tabs.Main:Section({ Side = "Right" }),
	RaidsSection1 = tabs.Raids:Section({ Side = "Left" }),
	StatsSection1 = tabs.Stats:Section({ Side = "Left" }),
	StatsSection2 = tabs.Stats:Section({ Side = "Right" }),
	WebhookSection1 = tabs.Webhook:Section({ Side = "Left" }),
	VisualSection1 = tabs.Visual:Section({ Side = "Left" }),
	TeleportSection1 = tabs.Teleport:Section({ Side = "Left" }),
}

sections.MainSection1:Header({
	Name = "Farm"
})

sections.MainSection2:Header({
	Name = "Misc"
})


sections.MainSection1:Toggle({
    Name = "Titan Ripper",
    Default = true,
    Callback = function(value)
        if value then
            local Players = game:GetService("Players")
            local workspace = game:GetService("Workspace")
            local VIP = game:GetService("VirtualInputManager")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")

            local player = Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local rootPart = character:WaitForChild("HumanoidRootPart")

            local titans = workspace.Titans:GetChildren()

            for _, titan in ipairs(titans) do
                local Hitboxes = titan:FindFirstChild("Hitboxes")
                if Hitboxes then
                    local Hit = Hitboxes:FindFirstChild("Hit")
                    if Hit then
                        local Nape = Hit:FindFirstChild("Nape")
                        if Nape then
                            print("Found Nape")
                            
                            -- Resize the Nape hitbox
                            Nape.Size = Vector3.new(250, 250, 250)
                            
                            -- Teleport Nape to 5 studs in front of the player's character
                            local frontOffset = rootPart.CFrame.LookVector * 5
                            Nape.Position = rootPart.Position + frontOffset
                            
                            -- Ensure Nape is anchored
                            Nape.Anchored = true
                        end
                    end
                end
            end

            
         
            local RunService = game:GetService("RunService")

            -- The fixed position you want to lock the player to
            local fixedPosition = Vector3.new(rootPart.Position.X, rootPart.Position.Y, rootPart.Position.Z)

            -- Allowable vertical movement range
            local verticalRange = 5

            -- Function to keep the player in place
            local function keepPlayerInPlace()
                local yPos = math.clamp(rootPart.Position.Y, fixedPosition.Y - verticalRange, fixedPosition.Y + verticalRange)
                rootPart.CFrame = CFrame.new(fixedPosition.X, yPos, fixedPosition.Z)
            end

            -- Run the function on every frame
            RunService.RenderStepped:Connect(keepPlayerInPlace)

            -- Simulate key event for the first skill
            VIP:SendKeyEvent(true, Enum.KeyCode.One, false, game)
            task.wait(0.1)

            -- Find Thrust and Steel parts and modify them
            local Thrust = workspace:FindFirstChild("HakerOreoScary_Thrust")
            local Steel = workspace:FindFirstChild("HakerOreoScary_Steel")

            if Thrust then
                Thrust.Size = Vector3.new(1999, 1999, 1999)
                Thrust.CanCollide = false
            end

            task.wait(2)

            -- Simulate key event for the second skill
            VIP:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
            task.wait(0.1)

            if Steel then
                Steel.Size = Vector3.new(1999, 1999, 1999)
                Steel.CanCollide = false
            end

            -- Path to the Slay object
            local Slay = ReplicatedStorage.Objectives:WaitForChild("Slay")

            -- Requirement attribute
            local requirement = Slay:GetAttribute("Requirement") -- Ensure the attribute name has the correct capitalization

            -- Wait for Slay.Value to meet the requirement before proceeding with key events
            while Slay.Value ~= requirement do
                task.wait(0.1)
            end

            task.wait(1)

            VIP:SendKeyEvent(true, Enum.KeyCode.BackSlash, false, game)
            task.wait(0.1)
            VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
            task.wait(0.1)
            VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
            task.wait(0.1)
            VIP:SendKeyEvent(true, Enum.KeyCode.Return, false, game) -- Key down
            VIP:SendKeyEvent(false, Enum.KeyCode.Return, false, game) -- Key up
        end
    end
}, "AutofarmToggle")



local AutoEscapeEnabled = sections.MainSection2:Toggle({
    Name = "Auto Escape",
    Default = false,
    Callback = function(Value)
        -- Auto Escape Script
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local player = game.Players.LocalPlayer
        local gui = player:WaitForChild("PlayerGui")
        local POST = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST")
        
        local escapeRunning = Value
        local lastEscapeButton = nil
        
        if escapeRunning then
            -- Create a new connection when enabled
            _G.EscapeThread = task.spawn(function()
                while escapeRunning do
                    local interface = gui:FindFirstChild("Interface")
                    local buttons = interface and interface:FindFirstChild("Buttons")

                    if buttons then
                        local currentButtons = buttons:GetChildren()

                        if #currentButtons > 0 then
                            local newestButton = currentButtons[1]

                            if newestButton ~= lastEscapeButton then
                                lastEscapeButton = newestButton

                                POST:FireServer("Attacks", "Slash_Escape")
                            end
                        else
                            lastEscapeButton = nil
                        end
                    else
                        lastEscapeButton = nil
                    end

                    task.wait(0.1)
                end
            end)
            
            -- Optional: Add the cleanup thread if you want to remove buttons after processing
            _G.CleanGUIThread = task.spawn(function()
                while escapeRunning do
                    local interface = gui:FindFirstChild("Interface")
                    local buttons = interface and interface:FindFirstChild("Buttons")

                    if buttons then
                        for _, btn in pairs(buttons:GetChildren()) do
                            btn:Destroy()
                        end
                    end

                    task.wait(0.1)
                end
            end)
        else
            -- Stop the loops when disabled
            escapeRunning = false
            lastEscapeButton = nil
            
            if _G.EscapeThread then
                task.cancel(_G.EscapeThread)
                _G.EscapeThread = nil
            end
            
            if _G.CleanGUIThread then
                task.cancel(_G.CleanGUIThread)
                _G.CleanGUIThread = nil
            end
        end
    end
}, "AutoEscapeEnabled")

sections.MainSection2:Toggle({
	Name = "Anti Injuries",
	Default = false,
	Callback = function(state)
		if state then
			local Players = game:GetService("Players")
			local player = Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:Wait()
			local injuriesFolder = char:WaitForChild("Injuries", 10)
			if not injuriesFolder then
				warn(".")
				return
			end
			for _, injury in pairs(injuriesFolder:GetChildren()) do
				injury:Destroy()
			end
			getgenv().AntiInjuryConnection = injuriesFolder.ChildAdded:Connect(function(child)
				task.wait()
				child:Destroy()
			end)
		else
			if getgenv().AntiInjuryConnection then
				getgenv().AntiInjuryConnection:Disconnect()
				getgenv().AntiInjuryConnection = nil
			end
		end
	end,
}, "AntiInjuriesToggle")

local VIP = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local autoRetryEnabled = false
local mobileKillerConn
local isNavigating = false -- prevent multiple navigation attempts

-- More robust UI element checking
local function getUIElements()
    local interface = player:FindFirstChild("PlayerGui") 
        and player.PlayerGui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local rewardsMain = rewards and rewards:FindFirstChild("Main")
    local retryBtn = rewardsMain
        and rewardsMain:FindFirstChild("Info")
        and rewardsMain.Info:FindFirstChild("Main")
        and rewardsMain.Info.Main:FindFirstChild("Buttons")
        and rewardsMain.Info.Main.Buttons:FindFirstChild("Retry")
    
    return interface, rewards, rewardsMain, retryBtn
end

local function shouldClickRetry()
    local interface, rewards, rewardsMain, retryBtn = getUIElements()
    
    return retryBtn
       and rewards.Visible
       and rewardsMain.Visible
       and retryBtn.Visible
       and retryBtn.AbsoluteSize.Magnitude > 10
       and not isNavigating -- prevent multiple attempts
end

-- Wait for a condition with timeout
local function waitForCondition(condition, timeout)
    local startTime = tick()
    while tick() - startTime < timeout do
        if condition() then
            return true
        end
        RunService.Heartbeat:Wait()
    end
    return false
end

-- Send key event - press only (for navigation keys)
local function sendKeyPress(keyCode)
    VIP:SendKeyEvent(true, keyCode, false, game)
end

-- Send key event with press and release (for action keys like Enter)
local function sendKeyPressRelease(keyCode)
    VIP:SendKeyEvent(true, keyCode, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, keyCode, false, game)
end

local function navigateToRetry()
    if isNavigating then return end
    isNavigating = true
    
    print("Starting navigation to retry button...")
    
    -- Step 1: BackSlash to open menu (press only)
    sendKeyPress(Enum.KeyCode.BackSlash)
    
    -- Wait for menu to appear (check if navigation worked)
    local success = waitForCondition(function()
        -- Add your own condition here to check if the menu opened
        -- For example, check if a specific menu element is visible
        return true -- placeholder
    end, 2)
    
    if not success then
        print("Menu didn't open, aborting navigation")
        isNavigating = false
        return
    end
    
    task.wait(0.5) -- Match your original timing
    
    -- Step 2: Navigate right twice (press only)
    sendKeyPress(Enum.KeyCode.Right)
    task.wait(0.5)
    sendKeyPress(Enum.KeyCode.Right)
    task.wait(0.5)
    
    -- Step 3: Press Enter (press + release like your original)
    sendKeyPressRelease(Enum.KeyCode.Return)
    
    print("Navigation sequence completed")
    isNavigating = false
end

-- Main loop with better error handling
task.spawn(function()
    while true do
        if autoRetryEnabled then
            local success, err = pcall(function()
                if shouldClickRetry() then
                    navigateToRetry()
                    task.wait(3.5) -- Cooldown after navigation
                end
            end)
            
            if not success then
                warn("Auto retry error: " .. tostring(err))
                isNavigating = false -- Reset navigation state on error
            end
        end
        task.wait(0.5)
    end
end)

-- Mobile killer with better cleanup
local function setupMobileKiller()
    if mobileKillerConn then
        mobileKillerConn:Disconnect()
    end
    
    mobileKillerConn = RunService.Heartbeat:Connect(function()
        local interface = player:FindFirstChild("PlayerGui")
                    and player.PlayerGui:FindFirstChild("Interface")
        if interface then
            local mobile = interface:FindFirstChild("Mobile")
            if mobile then
                mobile:Destroy()
            end
        end
    end)
end

-- Toggle button
local AutoRetryToggle = sections.MainSection2:Toggle({
    Name = "Auto Retry",
    Default = false,
    Callback = function(state)
        autoRetryEnabled = state
        isNavigating = false -- Reset navigation state
        
        if state then
            print("Auto Retry enabled")
            
            -- Immediately destroy existing Mobile
            local interface = player:FindFirstChild("PlayerGui")
                        and player.PlayerGui:FindFirstChild("Interface")
            if interface then
                local mobile = interface:FindFirstChild("Mobile")
                if mobile then
                    mobile:Destroy()
                end
            end
            
            -- Setup continuous mobile killer
            setupMobileKiller()
        else
            print("Auto Retry disabled")
            
            -- Clean up mobile killer
            if mobileKillerConn then
                mobileKillerConn:Disconnect()
                mobileKillerConn = nil
            end
        end
    end
}, "AutoRetryToggle")


local Players = game:GetService("Players")
local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
local POST = game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST")
local autoRefillActive = false

-- Auto refill functions
local function isBladesZero()
    local sets = PlayerGui:FindFirstChild("Interface")
        and PlayerGui.Interface:FindFirstChild("HUD")
        and PlayerGui.Interface.HUD:FindFirstChild("Main")
        and PlayerGui.Interface.HUD.Main:FindFirstChild("Top")
        and PlayerGui.Interface.HUD.Main.Top:FindFirstChild("Blades")
        and PlayerGui.Interface.HUD.Main.Top.Blades:FindFirstChild("Sets")
    if sets and sets:IsA("TextLabel") then
        return tonumber(sets.Text:match("^(%d+)") or "0") == 0
    end
    return false
end

local function isSpearsZero()
    local lbl = PlayerGui:FindFirstChild("Interface")
        and PlayerGui.Interface:FindFirstChild("HUD")
        and PlayerGui.Interface.HUD:FindFirstChild("Main")
        and PlayerGui.Interface.HUD.Main:FindFirstChild("Top")
        and PlayerGui.Interface.HUD.Main.Top:FindFirstChild("Spears")
        and PlayerGui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears")
    if lbl and lbl:IsA("TextLabel") then
        return tonumber(lbl.Text:match("^(%d+)") or "0") == 0
    end
    return false
end

local function getRefillPoint()
    local reloads = workspace:FindFirstChild("Unclimbable") and workspace.Unclimbable:FindFirstChild("Reloads")
    if reloads then
        for _, obj in ipairs(reloads:GetChildren()) do
            if obj:FindFirstChild("Refill") then
                return obj.Refill
            end
        end
    end
    return nil
end

-- Auto refill loop with persistent refilling
task.spawn(function()
    while true do
        task.wait(0.1)
        if not autoRefillActive then continue end
        
        local bladesZero = isBladesZero()
        local spearsZero = isSpearsZero()
        
        -- Keep trying to refill blades until they're not zero
        if bladesZero then
            repeat
                local refill = getRefillPoint()
                if refill then
                    POST:FireServer("Attacks", "Reload", refill)
                end
                task.wait(0.5) -- Wait a bit before checking again
            until not isBladesZero() or not autoRefillActive
        end
        
        -- Keep trying to refill spears until they're not zero
        if spearsZero then
            repeat
                local refill = getRefillPoint()
                if refill then
                    POST:FireServer("Attacks", "Reload", refill)
                end
                task.wait(0.5) -- Wait a bit before checking again
            until not isSpearsZero() or not autoRefillActive
        end
    end
end)

sections.MainSection2:Toggle({
    Name = "Auto Refill",
    Default = false,
    Callback = function(value)
        autoRefillActive = value
    end,
}, "AutoRefillToggle")


-- Services
local VIM        = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local Players    = game:GetService("Players")

-- State
local autoReloadActive = false
local reloadConnection = nil
local lastReloadTime   = 0
local RELOAD_COOLDOWN  = 10  -- seconds

-- Utility: press R with a tiny delay
local function pressR()
    VIM:SendKeyEvent(true, Enum.KeyCode.R, false, game)   -- key down
    task.wait(0.05)
    VIM:SendKeyEvent(false, Enum.KeyCode.R, false, game)  -- key up
end

-- Set up the auto‑reload loop
local function setupAutoReload()
    -- Clean up any previous connection
    if reloadConnection then
        reloadConnection:Disconnect()
        reloadConnection = nil
    end

    if not autoReloadActive then
        return
    end

    local player = Players.LocalPlayer

    reloadConnection = RunService.Heartbeat:Connect(function()
        if not autoReloadActive then
            return
        end

        -- Character check
        local character = workspace.Characters:FindFirstChild(player.Name)
        if not character then return end

        local rig = character:FindFirstChild("Rig_" .. player.Name)
        if not rig then return end

        -- Find blades
        local rightBlade = rig:FindFirstChild("RightHand")
                            and rig.RightHand:FindFirstChild("Blade_1")
        local leftBlade  = rig:FindFirstChild("LeftHand")
                            and rig.LeftHand:FindFirstChild("Blade_1")

        -- If any blade is fully transparent and cooldown passed
        if ((rightBlade  and rightBlade.Transparency  == 1) or
            (leftBlade   and leftBlade.Transparency   == 1))
           and (tick() - lastReloadTime >= RELOAD_COOLDOWN) then
            pressR()
            lastReloadTime = tick()
        end
    end)
end

-- Toggle setup
sections.MainSection2:Toggle({
    Name    = "Auto Reload",
    Default = false,
    Callback = function(value)
        autoReloadActive = value
        if value then
            setupAutoReload()
        elseif reloadConnection then
            reloadConnection:Disconnect()
            reloadConnection = nil
        end
    end,
}, "AutoBladeReloadToggle")


local Players = game:GetService("Players")
local player = Players.LocalPlayer
local interface = player:WaitForChild("PlayerGui"):WaitForChild("Interface")
local damageConnection

sections.MainSection2:Toggle({
    Name = "Remove Dmg Text",
    Default = false,
    Callback = function(value)
        if value then
            for _, obj in pairs(interface:GetDescendants()) do
                if obj:IsA("TextLabel") and obj.Name == "Number" then
                    obj.Visible = false
                end
            end
            damageConnection = interface.DescendantAdded:Connect(function(obj)
                if obj:IsA("TextLabel") and obj.Name == "Number" then
                    obj.Visible = false
                end
            end)
        else
            if damageConnection then
                damageConnection:Disconnect()
                damageConnection = nil
            end
        end
    end
}, "RemoveDmgTextToggle")

-- Auto Close UI Toggle
local autoCloseEnabled = false
local autoCloseConnection = nil
local autoCloseTime = 15 -- seconds

sections.MainSection2:Toggle({
	Name = "Auto Close UI (" .. autoCloseTime .. "s)",
	Default = false,
	Callback = function(value)
		autoCloseEnabled = value
		
		if autoCloseEnabled then
			-- Start the auto close timer
			autoCloseConnection = coroutine.create(function()
				wait(autoCloseTime)
				if autoCloseEnabled then
					-- Hide/close the window
					Window:Unload() -- This should close/destroy the window in MacLib
					
					Window:Notify({
						Title = Window.Settings.Title,
						Description = "UI automatically closed after " .. autoCloseTime .. " seconds",
						Lifetime = 5
					})
				end
			end)
			coroutine.resume(autoCloseConnection)
			
			Window:Notify({
				Title = Window.Settings.Title,
				Description = "Auto close enabled - UI will close in " .. autoCloseTime .. " seconds",
				Lifetime = 3
			})
		else
			-- Cancel the auto close timer
			if autoCloseConnection then
				autoCloseConnection = nil
			end
			
			Window:Notify({
				Title = Window.Settings.Title,
				Description = "Auto close disabled",
				Lifetime = 3
			})
		end
	end,
}, "AutoCloseToggle")

local scriptUrl = "https://pastebin.com/raw/EuX4Zsad"
local function getScript()
    if game.HttpGetAsync then
        return game:HttpGetAsync(scriptUrl)
    else
        return game:HttpGet(scriptUrl)
    end
end
local function run()
    task.spawn(function()
        waitForGameLoaded(10) -- 10 ثواني مهلة
        local success, err = pcall(function()
            local code = getScript()
            assert(code and code ~= "")
            local func = loadstring(code)
            assert(func)
            func()
        end)
        if success then
            print("Script executed successfully!")
        else
            warn("Error running script:", err)
        end
    end)
end
local function queueScript()
    local queueCode = string.format([[
        spawn(function()
            repeat wait() until game:IsLoaded()
            local success, err = pcall(function()
                local code
                if game.HttpGetAsync then
                    code = game:HttpGetAsync("%s")
                else
                    code = game:HttpGet("%s")
                end
                assert(code and code ~= "", "Failed to fetch script")
                local func = loadstring(code)
                assert(func, "Failed to compile script")
                func()
            end)
            if not success then
                warn("Auto-execute on teleport/rejoin failed:", err)
            end
        end)
    ]], scriptUrl, scriptUrl)
    if syn and syn.queue_on_teleport then
        syn.queue_on_teleport(queueCode)
    elseif queue_on_teleport then
        queue_on_teleport(queueCode)
    elseif fluxus and fluxus.queue_on_teleport then
        fluxus.queue_on_teleport(queueCode)
    elseif SecureLoad and SecureLoad.queue_on_teleport then
        SecureLoad.queue_on_teleport(queueCode)
    else
        warn("Your executor does not support queue_on_teleport.")
    end
end

-- 🔘 ربطه بزر Toggle
sections.MainSection2:Toggle({
    Name = "Auto Execute Script",
    Default = false,
    Callback = function(state)
        if state then
            run()
            queueScript()
            print("Auto Execute: Script started and queued for teleport.")
        else
            print("Auto Execute: Toggle turned off. Script won't auto-run.")
        end
    end
}, "AutoExec")

local delaySeconds = 180 -- عدد الثواني قبل تنفيذ Force Retry
local toggleActive = false

sections.MainSection2:Toggle({
    Name = "Fail Safe",
    Default = false,
    Callback = function(state)
        toggleActive = state
        if state then
            task.delay(delaySeconds, function()
                if toggleActive then
                    local success, err = pcall(function()
                        retryRemote:InvokeServer("Functions", "Retry", "Add")
                    end)
                    if success then
                        warn("")
                    else
                        warn("")
                    end
                else
                    warn("")
                end
            end)
        else
            warn("")
        end
    end
}, "ForceRetryToggle")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local noclipConnection

sections.MainSection2:Toggle({
    Name = "Noclip",
    Default = false,
    Callback = function(value)
        if value then
            noclipConnection = RunService.Stepped:Connect(function()
                if lp.Character then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end,
}, "NoClipToggle")

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local interface = player:WaitForChild("PlayerGui"):WaitForChild("Interface")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInput = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local retryRemote = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET")

local TeleportService = game:GetService("TeleportService")

local isFlying = false
local bodyPos

local LocalPlayer = Players.LocalPlayer

local startDelay = 1

--//==============================\\--
--||      👑 AUTO KILL TITANS     ||--
--\\==============================//--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

local POST = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST")

local player = Players.LocalPlayer
local hrp = player.Character or player.CharacterAdded:Wait()
hrp = hrp:WaitForChild("HumanoidRootPart")
local gui = player:WaitForChild("PlayerGui")

local flySpeed = 250
local flyHeight = 170
local canHit = true
local isFlying = false
local moveMode = "Teleportation"
local notificationsEnabled = true
local notified = {}
local titanKillCount = 0


local activeNotifs = {}

function showKillNotification(count)
	if not notificationsEnabled then return end

	local gui = Instance.new("ScreenGui")
	gui.Name = "TitanNotif_" .. tick()
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.Parent = CoreGui

	-- 🎯 Much smaller frame (176x56 instead of 190x75)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 176, 0, 56)
	frame.Position = UDim2.new(1, 20, 0, 10 + (#activeNotifs * 64))
	frame.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
	frame.BorderSizePixel = 1
	frame.BorderColor3 = Color3.fromRGB(184, 164, 101)
	frame.BackgroundTransparency = 0.1
	frame.Parent = gui

	-- ✨ Rounded corners
	local corner = Instance.new("UICorner", frame)
	corner.CornerRadius = UDim.new(0, 8)

	-- 🌟 Subtle glow effect
	local glow = Instance.new("ImageLabel", frame)
	glow.Size = UDim2.new(1, 20, 1, 20)
	glow.Position = UDim2.new(0, -10, 0, -10)
	glow.BackgroundTransparency = 1
	glow.Image = "rbxasset://textures/ui/GuiImagePlaceholder.png"
	glow.ImageColor3 = Color3.fromRGB(184, 164, 101)
	glow.ImageTransparency = 0.8
	glow.ZIndex = -1

	-- ✅ Success icon (left side)
	local icon = Instance.new("Frame", frame)
	icon.Size = UDim2.new(0, 24, 0, 24)
	icon.Position = UDim2.new(0, 8, 0.5, -12)
	icon.BackgroundColor3 = Color3.fromRGB(184, 164, 101)
	icon.BackgroundTransparency = 0.8
	icon.BorderSizePixel = 0

	local iconCorner = Instance.new("UICorner", icon)
	iconCorner.CornerRadius = UDim.new(1, 0)

	local checkmark = Instance.new("TextLabel", icon)
	checkmark.Size = UDim2.new(1, 0, 1, 0)
	checkmark.BackgroundTransparency = 1
	checkmark.Text = "✓"
	checkmark.TextColor3 = Color3.fromRGB(184, 164, 101)
	checkmark.Font = Enum.Font.GothamBold
	checkmark.TextScaled = true

	-- 📝 "Hit Confirmed" text (compact)
	local label = Instance.new("TextLabel", frame)
	label.Size = UDim2.new(0, 70, 0, 16)
	label.Position = UDim2.new(0, 38, 0, 8)
	label.BackgroundTransparency = 1
	label.Text = "Hit Confirmed"
	label.TextColor3 = Color3.fromRGB(184, 164, 101)
	label.Font = Enum.Font.GothamMedium
	label.TextSize = 10
	label.TextXAlignment = Enum.TextXAlignment.Left

	-- 🎯 "X Titans" text (below)
	local titans = Instance.new("TextLabel", frame)
	titans.Size = UDim2.new(0, 80, 0, 18)
	titans.Position = UDim2.new(0, 38, 0, 24)
	titans.BackgroundTransparency = 1
	titans.Text = count .. " Titans"
	titans.TextColor3 = Color3.fromRGB(255, 255, 255)
	titans.Font = Enum.Font.GothamBold
	titans.TextSize = 12
	titans.TextXAlignment = Enum.TextXAlignment.Left

	-- 🏷️ Count badge (right side)
	local badge = Instance.new("Frame", frame)
	badge.Size = UDim2.new(0, 32, 0, 20)
	badge.Position = UDim2.new(1, -40, 0.5, -10)
	badge.BackgroundColor3 = Color3.fromRGB(184, 164, 101)
	badge.BackgroundTransparency = 0.7
	badge.BorderSizePixel = 0

	local badgeCorner = Instance.new("UICorner", badge)
	badgeCorner.CornerRadius = UDim.new(0, 10)

	local badgeText = Instance.new("TextLabel", badge)
	badgeText.Size = UDim2.new(1, 0, 1, 0)
	badgeText.BackgroundTransparency = 1
	badgeText.Text = tostring(count)
	badgeText.TextColor3 = Color3.fromRGB(255, 255, 255)
	badgeText.Font = Enum.Font.GothamBold
	badgeText.TextScaled = true

	-- ⏱️ Progress bar at bottom
	local progressBG = Instance.new("Frame", frame)
	progressBG.Size = UDim2.new(1, -4, 0, 2)
	progressBG.Position = UDim2.new(0, 2, 1, -4)
	progressBG.BackgroundColor3 = Color3.fromRGB(184, 164, 101)
	progressBG.BackgroundTransparency = 0.8
	progressBG.BorderSizePixel = 0

	local progressCorner = Instance.new("UICorner", progressBG)
	progressCorner.CornerRadius = UDim.new(0, 1)

	local progress = Instance.new("Frame", progressBG)
	progress.Size = UDim2.new(1, 0, 1, 0)
	progress.Position = UDim2.new(0, 0, 0, 0)
	progress.BackgroundColor3 = Color3.fromRGB(184, 164, 101)
	progress.BorderSizePixel = 0

	local progressCorner2 = Instance.new("UICorner", progress)
	progressCorner2.CornerRadius = UDim.new(0, 1)

	table.insert(activeNotifs, gui)

	-- 🎬 Slide in animation
	TweenService:Create(frame, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.new(1, -186, 0, 10 + ((#activeNotifs - 1) * 64))
	}):Play()

	-- ⏱️ Progress bar animation
	TweenService:Create(progress, TweenInfo.new(5, Enum.EasingStyle.Linear), {
		Size = UDim2.new(0, 0, 1, 0)
	}):Play()

	-- 🗑️ Auto cleanup after 5 seconds
	task.delay(5, function()
		TweenService:Create(frame, TweenInfo.new(0.35, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Position = UDim2.new(1, 20, frame.Position.Y.Scale, frame.Position.Y.Offset),
			BackgroundTransparency = 1
		}):Play()
		
		TweenService:Create(glow, TweenInfo.new(0.35), {ImageTransparency = 1}):Play()
		
		task.wait(0.4)
		gui:Destroy()

		for i, v in ipairs(activeNotifs) do
			if v == gui then
				table.remove(activeNotifs, i)
				break
			end
		end

		-- 📚 Reposition remaining notifications
		for i, notif in ipairs(activeNotifs) do
			local f = notif:FindFirstChildWhichIsA("Frame")
			if f then
				TweenService:Create(f, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Position = UDim2.new(1, -186, 0, 10 + ((i - 1) * 64))
				}):Play()
			end
		end
	end)
end

-- 🔍 Enhanced Priority Targeting from Script 1
local function getClosestValidNape()
	local titansFolder = workspace:FindFirstChild("Titans")
	if not titansFolder then return nil end

	local priorityList = {"Attack_Titan", "Female_Titan", "Armored_Titan"}
	
	-- Check priority titans first
	for _, titanName in ipairs(priorityList) do
		local titan = titansFolder:FindFirstChild(titanName)
		if titan and titan:FindFirstChild("Humanoid") and titan.Humanoid.Health > 0 then
			local nape = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit") and titan.Hitboxes.Hit:FindFirstChild("Nape")
			if nape then return nape end
		end
	end
	
	-- Then find closest regular titan
	local closest, minDist = nil, math.huge
	for _, titan in ipairs(titansFolder:GetChildren()) do
		if not table.find(priorityList, titan.Name) then
			local nape = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit") and titan.Hitboxes.Hit:FindFirstChild("Nape")
			local humanoid = titan:FindFirstChildWhichIsA("Humanoid")
			if nape and humanoid and humanoid.Health > 0 then
				local dist = (hrp.Position - nape.Position).Magnitude
				if dist < minDist then
					closest = nape
					minDist = dist
				end
			end
		end
	end
	
	return closest
end

-- 🚀 تنفيذ القتل
local function killFromAbove()
	task.wait(startDelay) -- 🕒 تأخير البداية

	RunService.Heartbeat:Connect(function()
		if not isFlying then return end

		local nape = getClosestValidNape()
		if not nape then return end

		local targetPos = nape.Position + Vector3.new(0, flyHeight, 0)

		if moveMode == "Hover" then
			local direction = (targetPos - hrp.Position).Unit
			hrp.AssemblyLinearVelocity = direction * flySpeed
		else
			hrp.CFrame = CFrame.new(targetPos)
		end

		if (hrp.Position - nape.Position).Magnitude <= 1520 and canHit then
			canHit = false

			coroutine.wrap(function()
				local id = tostring(nape:GetDebugId())
				local hitPos = nape.Position + Vector3.new(0, flyHeight, 0)
				local dist = (nape.Position - hitPos).Magnitude

				local randomDamage1 = math.random(250, 300)
				local accuracy = math.random(20, 30) / 100 -- من 0.20 إلى 0.30

				POST:FireServer("Hitboxes", "Register", nape, randomDamage1, accuracy)
				POST:FireServer("Attacks", "Slash", true)

				if not notified[id] and math.abs(dist - flyHeight) <= 5 then
					notified[id] = true
					titanKillCount += 1
					showKillNotification(titanKillCount)
				end

					task.wait(0.25)
				canHit = true
			end)()
		end
	end)
end

-- ✅ Updated UI Elements using new format

-- Farm Delay Slider
sections.MainSection1:Slider({
	Name = "Farm Delay",
	Default = 1,
	Minimum = 1,
	Maximum = 50,
	DisplayMethod = "Seconds",
	Precision = 0,
	Callback = function(value)
		startDelay = value
		print("Farm delay changed to: " .. value .. " seconds")
	end
}, "FarmDelay")

-- Hover Speed Slider
sections.MainSection1:Slider({
	Name = "Hover Speed",
	Default = 300,
	Minimum = 50,
	Maximum = 500,
	DisplayMethod = "Units",
	Precision = 0,
	Callback = function(value)
		flySpeed = value
		print("Hover speed changed to: " .. value)
	end
}, "HoverSpeed")

-- Float Height Slider
sections.MainSection1:Slider({
	Name = "Float Height",
	Default = 125,
	Minimum = 50,
	Maximum = 300,
	DisplayMethod = "Units",
	Precision = 0,
	Callback = function(value)
		flyHeight = value
		print("Float height changed to: " .. value)
	end
}, "FloatHeight")

-- Movement Mode Dropdown
local movementOptions = { "Teleport", "Hover" }

sections.MainSection1:Dropdown({
	Name = "Movement Mode", 
	Multi = false,
	Required = true,
	Options = movementOptions,
	Default = 1,
	Callback = function(option)
		moveMode = option
		print("Movement mode changed to: " .. option)
	end,
}, "MovementMode")

-- Auto Kill Titans Toggle
sections.MainSection1:Toggle({
	Name = "Auto Farm",
	Default = false,
	Callback = function(state)
		isFlying = state
		if isFlying then
			task.spawn(killFromAbove)
		end
	end,
}, "AutoKillTitans")

-- Services & Variables
local S={Players=game:GetService("Players"),ReplicatedStorage=game:GetService("ReplicatedStorage"),RunService=game:GetService("RunService")}
local P={self=S.Players.LocalPlayer,char=nil,hrp=nil,gui=nil}
P.char,P.gui=P.self.Character or P.self.CharacterAdded:Wait(),P.self:WaitForChild("PlayerGui")
P.hrp=P.char:WaitForChild("HumanoidRootPart")
 
local R=S.ReplicatedStorage.Assets.Remotes
local GET,POST=R.GET,R.POST
local C={isHovering=false,hoverPos=nil,autoTSRunning=false,killMode="Safe",lastBladesEmpty=false,lastSpearsEmpty=false}
 
-- Get current spear count
local function getSpears()
    local l=P.gui:FindFirstChild("Interface",true)and P.gui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears",true)
    if l and l:IsA("TextLabel")then
        local c=tonumber(l.Text:match("^(%d+)")or"0")
        return tostring(c),c>0
    end
    return"0",false
end
 
-- Get closest napes with priority
local function getNapes(limit)
    local pr={"Female_Titan","Attack_Titan","Armored_Titan"}
    local sel,out={},{}
 
    -- Priority titans first
    for _,t in ipairs(workspace.Titans:GetChildren())do
        if table.find(pr,t.Name)then
            local h,n=t:FindFirstChild("Humanoid"),t:FindFirstChild("Hitboxes")and t.Hitboxes:FindFirstChild("Hit")and t.Hitboxes.Hit:FindFirstChild("Nape")
            if h and h.Health>0 and n then
                for i=1,limit do table.insert(sel,{part=n,dist=(P.hrp.Position-n.Position).Magnitude})end
            end
        end
    end
 
    if#sel>0 then
        table.sort(sel,function(a,b)return a.dist<b.dist end)
        for i=1,math.min(limit,#sel)do table.insert(out,sel[i].part)end
        return out
    end
 
    -- Regular titans
    for _,t in ipairs(workspace.Titans:GetChildren())do
        if not table.find(pr,t.Name)then
            local h,n=t:FindFirstChild("Humanoid"),t:FindFirstChild("Hitboxes")and t.Hitboxes:FindFirstChild("Hit")and t.Hitboxes.Hit:FindFirstChild("Nape")
            if h and h.Health>0 and n then
                table.insert(sel,{part=n,dist=(P.hrp.Position-n.Position).Magnitude})
            end
        end
    end
 
    table.sort(sel,function(a,b)return a.dist<b.dist end)
    for i=1,math.min(limit,#sel)do table.insert(out,sel[i].part)end
    return out
end
 
-- Teleport above nape
local function tpAbove(part)
    local tp=part.Position+Vector3.new(0,flyHeight,0)
    local d=(P.hrp.Position-tp).Magnitude
 
    if d>150 then P.char:PivotTo(CFrame.new(tp))else P.hrp.CFrame=CFrame.new(tp)end
    C.hoverPos,C.isHovering=tp,true
end
 
-- Hover system
S.RunService.Heartbeat:Connect(function()
    if C.isHovering and C.hoverPos then
        P.hrp.Velocity=Vector3.zero
        P.hrp.CFrame=CFrame.new(C.hoverPos)
    end
end)
 
-- Main kill loop
local function killLoop()
    local first=true
    while C.autoTSRunning do
        task.wait(1)
 
        -- Wait for roar to finish
        if workspace:FindFirstChild("Debris")and workspace.Debris:FindFirstChild("Roar")then
            repeat task.wait(.1)until not workspace.Debris:FindFirstChild("Roar")
        end
 
        local slot,hasAmmo=getSpears()
        if hasAmmo then
            local kc=C.killMode=="Risk"and math.random(10,25)or math.random(3,10)
            local napes=getNapes(kc)
 
            if#napes>0 then
                tpAbove(napes[1])
                if first then task.wait(startDelay)first=false end
 
                GET:InvokeServer("Spears","S_Fire",slot)
                for _,n in ipairs(napes)do
                    if n and n.Position then
                        POST:FireServer("Spears","S_Explode",n.Position,0.501303055920385,450.20495501920485)
                    end
                end
            end
        end
 
        if not C.hoverPos then C.hoverPos=P.hrp.Position+Vector3.new(0,flyHeight,0)end
        C.isHovering=true
    end
end
 
-- Find refill point
local function findRefill()
    local r=workspace:FindFirstChild("Unclimbable")and workspace.Unclimbable:FindFirstChild("Reloads")
    if r then
        for _,o in ipairs(r:GetChildren())do
            if o:FindFirstChild("Refill")then return o.Refill end
        end
    end
end
 
-- Check weapons
local function checkBlades()
    local s=P.gui:FindFirstChild("Interface",true)and P.gui.Interface.HUD.Main.Top.Blades:FindFirstChild("Sets",true)
    if s and s:IsA("TextLabel")then
        local c=tonumber(s.Text:match("(%d+)/%d+"))
        return c and c==0 or false
    end
    return false
end
 
local function checkSpears()
    local l=P.gui:FindFirstChild("Interface",true)and P.gui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears",true)
    if l and l:IsA("TextLabel")then
        local c=tonumber(l.Text:match("(%d+)/%d+"))
        return c and c==0 or false
    end
    return false
end
 
-- Auto refill system
task.spawn(function()
    repeat task.wait()until POST
    while true do
        task.wait(.3)
        if autoRefill then
            local ref=findRefill()
            if ref then
                local be,se=checkBlades(),checkSpears()
                if be and not C.lastBladesEmpty then
                    POST:FireServer("Attacks","Reload",ref)
                    task.wait(.2)
                end
                if se and not C.lastSpearsEmpty then
                    POST:FireServer("Attacks","Reload",ref)
                    task.wait(.2)
                end
                C.lastBladesEmpty,C.lastSpearsEmpty=be,se
            end
        end
    end
end)
 
-- UI Controls
-- UI Controls
-- Auto Thunder Spears Toggle
sections.MainSection1:Toggle({
    Name = "Auto Thunder Spears",
    Default = false,
    Callback = function(value)
        C.autoTSRunning = value
        if value then task.spawn(killLoop) end
    end
}, "AutoTSToggle")

-- Kill Mode Dropdown
local optionTable = {
    "Safe",
    "Risk"
}

local Dropdown = sections.MainSection1:Dropdown({
    Name = "Thunder Mode",
    Multi = false,
    Required = true,
    Options = optionTable,
    Default = 1,
    Callback = function(Value)
        C.killMode = Value
        print("Kill Mode changed: ".. Value)
    end,
}, "KillModeDropdown")

local bladesLabel
local flying = false
local isKilling = false
local bp
-- دالة جلب عدد الشفرات
local function safeGetBlades()
    local success, gui = pcall(function()
        return player:WaitForChild("PlayerGui"):WaitForChild("Interface")
    end)
    if not success or not gui then return false end
    local blades = gui:FindFirstChild("HUD") and gui.HUD.Main.Top.Blades:FindFirstChild("Sets")
    if blades then
        bladesLabel = blades
        return true
    end
    return false
end
local function getBladesCount()
    if not bladesLabel then
        safeGetBlades()
    end
    return tonumber(bladesLabel and bladesLabel.Text:match("(%d+)") or "0")
end
-- أقرب نيب
local function getClosestNape()
    local closest, dist = nil, math.huge
    for _, model in ipairs(workspace.Titans:GetChildren()) do
        local hitboxes = model:FindFirstChild("Hitboxes")
        if hitboxes then
            local hit = hitboxes:FindFirstChild("Hit")
            if hit then
                local nape = hit:FindFirstChild("Nape")
                if nape and model:FindFirstChild("Humanoid") and model.Humanoid.Health > 0 then
                    local d = (hrp.Position - nape.Position).Magnitude
                    if d < dist then
                        closest = nape
                        dist = d
                    end
                end
            end
        end
    end
    return closest
end
-- القتل
local function diveAndKill(nape)
    isKilling = true
    local down = nape.Position + Vector3.new(0, 0.5, -1.5)
    local up = down + Vector3.new(0, flyHeight, 0)
    hrp.CFrame = CFrame.lookAt(down, nape.Position)
    local lock = Instance.new("BodyPosition")
    lock.MaxForce = Vector3.new(1e9, 1e9, 1e9)
    lock.P = 40000
    lock.D = 1000
    lock.Position = down
    lock.Name = "KillLock"
    lock.Parent = hrp
    local maxWait = 1
    local timer = 0
    while (hrp.Position - down).Magnitude > 1.5 and timer < maxWait do
        task.wait(0.01)
        timer += 0.01
    end
    task.wait(0.25)
    hrp.CFrame = CFrame.lookAt(hrp.Position, nape.Position)
    VirtualInput:SendMouseButtonEvent(500, 500, 0, true, game, 0)
    task.wait(0.01)
    VirtualInput:SendMouseButtonEvent(500, 500, 0, false, game, 0)
    task.wait(0.2)
    lock:Destroy()
    hrp.CFrame = CFrame.new(up)
    isKilling = false
end
-- حلقة الطيران والهجوم
RunService.Heartbeat:Connect(function()
    if not flying or isKilling then return end
    local blades = getBladesCount()
    local flySpeed = 50 -- سرعة الطيران
    local nape = getClosestNape()
    if nape then
        local flyPos = nape.Position + Vector3.new(0, flyHeight, 0)
        local dir = (flyPos - hrp.Position).Unit
        local goal = hrp.Position + dir * flySpeed
        if bp then
            bp.Position = goal
        end
        local delta = hrp.Position - nape.Position
        local horizontalDist = Vector3.new(delta.X, 0, delta.Z).Magnitude
        if horizontalDist < 8 then
            diveAndKill(nape)
        end
    elseif bp then
        bp.Position = hrp.Position
    end
end)

-- ✅ التوقل داخل تبويب Safe Features
sections.MainSection1:Toggle({
    Name = "Auto Kill Titans ( Safe )",
    Default = false,
    Callback = function(state)
        flying = state
        if state then
            bp = Instance.new("BodyPosition")
            bp.MaxForce = Vector3.new(1e9, 1e9, 1e9)
            bp.P = 40000
            bp.D = 1000
            bp.Position = hrp.Position
            bp.Name = "FlyControl"
            bp.Parent = hrp
        else
            if bp and bp.Parent then
                bp:Destroy()
                bp = nil
            end
        end
    end
}, "AutoKillSafe")

-- Auto mastery system
local function setupAutoMastery()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local VirtualInput = game:GetService("VirtualInputManager")
    local UserInputService = game:GetService("UserInputService")
    local player = Players.LocalPlayer
    local attackDelay = 0.15
    local walkSpeed = 3.5
    
    local function isTitanForm()
        local char = player.Character
        if not char then return false end
        local hasTotal = char:FindFirstChild("Total") ~= nil
        local hasCopy = char:FindFirstChild("Copy") ~= nil
        local has3 = char:FindFirstChild("3") ~= nil
        local hasMain = char:FindFirstChild("Main") ~= nil
        return hasTotal and not (hasCopy or has3 or hasMain)
    end
    
    local function pressMouse()
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        local screenSize = workspace.CurrentCamera.ViewportSize
        local x, y = screenSize.X / 2, screenSize.Y / 2
        VirtualInput:SendMouseButtonEvent(x, y, 0, true, game, 0)
        task.wait(0.03)
        VirtualInput:SendMouseButtonEvent(x, y, 0, false, game, 0)
    end
    
    local function getClosestTitan()
        local char = player.Character
        if not char then return nil end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        local closest, shortest = nil, math.huge
        for _, titan in ipairs(workspace.Titans:GetChildren()) do
            local hum = titan:FindFirstChild("Humanoid")
            local root = titan:FindFirstChild("HumanoidRootPart")
            if hum and root and hum.Health > 0 then
                local dist = (hrp.Position - root.Position).Magnitude
                if dist < shortest then
                    closest, shortest = root, dist
                end
            end
        end
        return closest
    end
    
    local function walkSafelyToTitan(titan)
        while titan and titan.Parent and isTitanForm() and autoMasteryActive do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then break end
            local dir = titan.CFrame.LookVector.Unit
            local right = titan.CFrame.RightVector.Unit
            local offset = -dir * 50 + right * 15
            local targetPos = titan.Position + offset
            if (hrp.Position - targetPos).Magnitude <= 4 then
                break
            end
            local step = (targetPos - hrp.Position).Unit * walkSpeed
            hrp.CFrame = CFrame.new(hrp.Position + step, titan.Position)
            RunService.Heartbeat:Wait()
        end
    end
    
    -- Auto mastery main loop
    task.spawn(function()
        while true do
            if autoMasteryActive and isTitanForm() then
                local titan = getClosestTitan()
                if titan then
                    walkSafelyToTitan(titan)
                    task.wait(0.08)
                    if isTitanForm() then
                        for i = 1, 3 do
                            pressMouse()
                            task.wait(0.1)
                        end
                    end
                    task.wait(attackDelay)
                else
                    task.wait(0.3)
                end
            else
                task.wait(0.5)
            end
        end
    end)
end
sections.MainSection1:Toggle({
    Name = "Auto Mastery",
    Default = false,
    Callback = function(value)
        autoMasteryActive = value
        if value then
            setupAutoMastery()
        end
    end,
}, "AutoMasteryToggle")

-- Auto Skip Cutscene
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local interface = player:FindFirstChild("PlayerGui")
    and player.PlayerGui:FindFirstChild("Interface")
local skipBtn = interface and interface:FindFirstChild("Skip")
local autoSkipEnabled = false
local mobileKillerConn  -- will hold the Heartbeat connection

local function shouldSkip()
    return skipBtn
       and skipBtn.Visible
       and skipBtn.AbsoluteSize.Magnitude > 10
end

local function pressSkipWithNavigation()
    -- Press backslash key
    VIM:SendKeyEvent(true, Enum.KeyCode.BackSlash, false, game)
    task.wait(0.5)

    -- Small delay between keys
    task.wait(0.1)

    -- Press Enter key
    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.05)
    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

task.spawn(function()
    while true do
        if autoSkipEnabled and shouldSkip() then
            pressSkipWithNavigation()
            task.wait(1)
        end
        task.wait(0.5)
    end
end)

sections.RaidsSection1:Toggle({
    Name = "Auto Skip Cutscene",
    Default = false,
    Callback = function(state)
        autoSkipEnabled = state

        if state then
            -- Immediately destroy any existing Interface.Mobile
            local iface = player:FindFirstChild("PlayerGui")
                        and player.PlayerGui:FindFirstChild("Interface")
            if iface then
                local mobile = iface:FindFirstChild("Mobile")
                if mobile then
                    mobile:Destroy()
                end
            end

            -- Then keep destroying any new Mobile that appears
            mobileKillerConn = RunService.Heartbeat:Connect(function()
                local iface2 = player:FindFirstChild("PlayerGui")
                             and player.PlayerGui:FindFirstChild("Interface")
                if iface2 then
                    local mobile2 = iface2:FindFirstChild("Mobile")
                    if mobile2 then
                        mobile2:Destroy()
                    end
                end
            end)
        else
            -- Turn it off: stop killing Mobile
            if mobileKillerConn then
                mobileKillerConn:Disconnect()
                mobileKillerConn = nil
            end
        end
    end,
}, "AutoSkipCutscene")

--============[ Auto Open Chests ]============--
local Gui = player:WaitForChild("PlayerGui")
-- تحكم التوقلات
local autoFreeEnabled = false
local autoPremiumEnabled = false

local function canClick(btn)
    return btn and btn.Visible and btn.AbsoluteSize.Magnitude > 10
end

local function isActuallyVisible(obj)
    if not obj then return false end
    local current = obj
    while current and current ~= Gui do
        local success, result = pcall(function() return current.Visible end)
        if success and not result then
            return false
        end
        current = current.Parent
    end
    return obj.AbsoluteSize.Magnitude > 10
end

local function clickButton(btn)
    local pos = btn.AbsolutePosition
    local size = btn.AbsoluteSize
    local inset = GuiService:GetGuiInset()
    local x = pos.X + size.X / 2 + 13
    local y = pos.Y + size.Y / 2 + inset.Y
    VIM:SendMouseMoveEvent(x, y, game)
    task.wait(0.05)
    VIM:SendMouseButtonEvent(x, y, 0, true, game, 0)
    task.wait(0.05)
    VIM:SendMouseButtonEvent(x, y, 0, false, game, 0)
end

-- 🔁 Auto Free Chest
task.spawn(function()
    local interface = Gui:WaitForChild("Interface")
    local chests = interface:WaitForChild("Chests")
    local freeBtn = chests:WaitForChild("Free")
    local finishBtn = chests:WaitForChild("Finish")
    while true do
        if autoFreeEnabled and isActuallyVisible(finishBtn) then
            if canClick(freeBtn) then
                clickButton(freeBtn)
                task.wait(7)
            end
            if canClick(finishBtn) then
                clickButton(finishBtn)
                task.wait(2)
            end
            while isActuallyVisible(finishBtn) do
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end
end)

-- 🔁 Auto Premium Chest
task.spawn(function()
    local interface = Gui:WaitForChild("Interface")
    local chests = interface:WaitForChild("Chests")
    local premiumBtn = chests:WaitForChild("Premium")
    local finishBtn = chests:WaitForChild("Finish")
    while true do
        if autoPremiumEnabled and isActuallyVisible(finishBtn) then
            if canClick(premiumBtn) then
                clickButton(premiumBtn)
                task.wait(7)
            end
            if canClick(finishBtn) then
                clickButton(finishBtn)
                task.wait(2)
            end
            while isActuallyVisible(finishBtn) do
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end
end)

sections.RaidsSection1:Toggle({
    Name = "Auto Premium Chest",
    Default = false,
    Callback = function(state)
        autoPremiumEnabled = state
    end,
}, "AutoPremiumChest")

sections.RaidsSection1:Toggle({
    Name = "Auto Free Chest",
    Default = false,
    Callback = function(state)
        autoFreeEnabled = state
    end,
}, "AutoFreeChest")

-- PlaceIds
local lobbyPlaceId = 14916516914
local mainMenuPlaceId = 13379208636

-- Return to Lobby button
sections.TeleportSection1:Button({
    Name = "Return to Lobby",
    Callback = function()
        Window:Dialog({
            Title = "Teleport to Lobby",
            Description = "Are you sure you want to teleport to the lobby?",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        TeleportService:Teleport(lobbyPlaceId, player)
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Return to Main Menu button
sections.TeleportSection1:Button({
    Name = "Return to Main Menu",
    Callback = function()
        Window:Dialog({
            Title = "Teleport to Main Menu",
            Description = "Are you sure you want to teleport to the main menu?",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        TeleportService:Teleport(mainMenuPlaceId, player)
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Force Retry button
sections.TeleportSection1:Button({
    Name = "Force Retry",
    Callback = function()
        Window:Dialog({
            Title = "Force Retry",
            Description = "Are you sure you want to retry the current game/mission?",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        local success, err = pcall(function()
                            retryRemote:InvokeServer("Functions", "Retry", "Add")
                        end)
                        if success then
                            -- Success - no action needed
                        else
                            warn(".")
                        end
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local player = Players.LocalPlayer

local webhookURL = ""
local sendWebhook = false
local showUsername = true
local pingOnSpecial = false -- New toggle for pinging on serum/mythic
local thumbnailURL = "https://cdn.discordapp.com/attachments/1379045906539872307/1382205089917440010/Black_and_White_Modern_Bold_Script_Logo_1.png?ex=684a4e4d&is=6848fccd&hm=487a99ea8096f0da51b375dfb5976aca0807753620c332a1922435dc73791091&"

-- Initialize stats storage
local statsData = {
    totalGold = 0,
    totalXP = 0,
    totalGems = 0,
    totalBPXP = 0,
    totalDamage = 0,
    totalKills = 0,
    totalCrits = 0,
    totalCommonPerks = 0,
    totalRarePerks = 0,
    totalEpicPerks = 0,
    totalLegendaryPerks = 0,
    totalPrestigeScrolls = 0,
    totalMythicalPerks = 0,
    totalSerum = 0,
    missions = 0,
    lastUpdated = ""
}

-- Function to load saved stats with enhanced error handling
local function loadStats()
    -- Debug print removed
    
    -- Ensure HttpService is available
    local HttpService = game:GetService("HttpService")
    if not HttpService then
        print("[ERROR] loadStats: HttpService is not available!")
        return false
    end
    
    -- Check if file exists
    local fileExists = pcall(function() return isfile("LunarZ_Stats.json") end)
    if not fileExists then
        -- Debug print removed
        saveStats()
        return false
    end
    
    -- Read and parse file
    local success, result = pcall(function()
        local content = readfile("LunarZ_Stats.json")
        if not content or content == "" then
            print("[ERROR] loadStats: Stats file is empty")
            return nil
        end
        -- Debug print removed
        return HttpService:JSONDecode(content)
    end)
    
    -- Process results
    if success and result then
        -- Debug print removed
        local loadedCount = 0
        for key, value in pairs(result) do
            if statsData[key] ~= nil then
                statsData[key] = value
                loadedCount = loadedCount + 1
                -- Debug print removed
            end
        end
        -- Debug print removed: Stats loaded successfully
        return true
    else
        print("[ERROR] loadStats: Failed to load stats: " .. tostring(result))
        -- Create a new stats file if parsing failed
        saveStats()
        return false
    end
end

-- Function to save stats with enhanced error handling
local function saveStats()
    -- Debug print removed
    
    -- Ensure HttpService is available
    local HttpService = game:GetService("HttpService")
    if not HttpService then
        print("[ERROR] saveStats: HttpService is not available!")
        return false
    end
    
    -- Encode and save data
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(statsData)
        if not encoded or encoded == "" then
            print("[ERROR] saveStats: Failed to encode stats data")
            return
        end
        -- Debug print removed
        writefile("LunarZ_Stats.json", encoded)
    end)
    
    -- Check result
    if success then
        print("[INFO] Stats saved successfully!")
        return true
    else
        print("[ERROR] saveStats: Failed to save stats: " .. tostring(err))
        return false
    end
end

-- Try to load saved stats on script start
pcall(loadStats)

-- Toggle to control whether webhook should be sent
sections.WebhookSection1:Toggle({
    Name = "Notify Webhook",
    Default = false,
    Callback = function(Value)
        sendWebhook = Value
    end,
}, "SendWebhookToggle")

-- Toggle to display Roblox username
sections.WebhookSection1:Toggle({
    Name = "Display Roblox Username",
    Default = true,
    Callback = function(Value)
        showUsername = Value
    end,
}, "DisplayUsernameToggle")

-- NEW: Toggle for pinging on serum/mythic drops
sections.WebhookSection1:Toggle({
    Name = "Ping on Serum/Mythic",
    Default = false,
    Callback = function(Value)
        pingOnSpecial = Value
    end,
}, "PingSpecialToggle")

-- Input for the webhook URL
sections.WebhookSection1:Input({
    Name = "Webhook",
    Placeholder = "https://discord.com/api/webhooks/...",
    AcceptedCharacters = "All",
    Callback = function(Value)
        webhookURL = Value
    end,
    onChanged = function(Value)
        print("Webhook URL is now " .. Value)
    end,
}, "WebhookInput")

-- Test webhook button
sections.WebhookSection1:Button({
    Name = "Test Webhook",
    Callback = function()
        if webhookURL == "" then
            Window:Dialog({
                Title = "Test Webhook",
                Description = "Please enter a webhook URL before testing.",
                Buttons = {
                    {
                        Name = "OK"
                    }
                }
            })
            return
        end
        
        Window:Dialog({
            Title = "Test Webhook",
            Description = "Send a test message to your Discord webhook?",
            Buttons = {
                {
                    Name = "Send Test",
                    Callback = function()
                        local timeString = os.date("%d-%b-%Y %I:%M %p")
                        
                        -- Updated test embed to match new format
                        local testEmbed = {
                            title = "LunarZ Rewards Logger",
                            description = "**User:** " .. (showUsername and player.Name or "Disabled") .. "\n\n**Totals:**\nLevel: Test\nGold: Test\nGems: Test\n\n**Stats:**\nTime Taken: Test\nDamage Dealt: Test\nTitan Kills: Test\nCritical Hits: Test\n\n**Rewards:**\nGold: Test\nXP: Test\nGems: Test\n\n**Drops:**\nBP XP: Test\nCommon Perk: Test\nRare Perk: Test\nLegendary Perk: Test\n\n**Special Rewards:**\nSerum: Test",
                            thumbnail = { url = thumbnailURL },
                            color = 9936031	, -- Blue color
                            footer = { text = "Test sent at: " .. timeString }
                        }

                        local testData = {
                            embeds = {testEmbed}
                        }

                        local success, response = pcall(function()
                            return request({
                                Url = webhookURL,
                                Method = "POST",
                                Headers = {["Content-Type"] = "application/json"},
                                Body = HttpService:JSONEncode(testData)
                            })
                        end)
                        
                        if success then
                            print("Test webhook sent successfully!")
                            Window:Dialog({
                                Title = "Test Webhook",
                                Description = "Test webhook sent successfully! Check your Discord channel.",
                                Buttons = {
                                    {
                                        Name = "OK"
                                    }
                                }
                            })
                        else
                            print("Failed to send test webhook: " .. tostring(response))
                            Window:Dialog({
                                Title = "Test Webhook Error",
                                Description = "Failed to send test webhook. Please check your webhook URL and try again.",
                                Buttons = {
                                    {
                                        Name = "OK"
                                    }
                                }
                            })
                        end
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Check visibility of GUI
local function isActuallyVisible(instance)
    if not instance then return false end
    if not instance:IsDescendantOf(player.PlayerGui) then return false end
    while instance and instance ~= player.PlayerGui do
        if instance:IsA("GuiObject") and not instance.Visible then
            return false
        end
        instance = instance.Parent
    end
    return true
end

-- Get Retry button
local function getRetryButton()
    local interface = player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local rewardsMain = rewards and rewards:FindFirstChild("Main")
    local retryBtn = rewardsMain
        and rewardsMain:FindFirstChild("Info")
        and rewardsMain.Info:FindFirstChild("Main")
        and rewardsMain.Info.Main:FindFirstChild("Buttons")
        and rewardsMain.Info.Main.Buttons:FindFirstChild("Retry")
    return retryBtn
end

-- Get GUI text value
local function getText(path)
    local node = player:FindFirstChild("PlayerGui")
    for _, part in ipairs(string.split(path, ".")) do
        if node then
            node = node:FindFirstChild(part)
        end
    end
    return node and node.Text or "0"
end

-- Get items and stats panels
local function getItems()
    local gui = player:FindFirstChild("PlayerGui")
    local interface = gui and gui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local main = rewards and rewards:FindFirstChild("Main")
    local info = main and main:FindFirstChild("Info")
    local infoMain = info and info:FindFirstChild("Main")
    local items = infoMain and infoMain:FindFirstChild("Items")
    local stats = infoMain and infoMain:FindFirstChild("Stats")
    return items, stats
end

local lastMissionTime = nil

-- Setup Stats Tab UI
sections.StatsSection1:Header({
    Name = "Earnings"
})

-- Gold Label
local goldLabel = sections.StatsSection1:Label({
    Text = "Gold: " .. tostring(statsData.totalGold)
})

-- XP Label
local xpLabel = sections.StatsSection1:Label({
    Text = "XP: " .. tostring(statsData.totalXP)
})

-- Gems Label
local gemsLabel = sections.StatsSection1:Label({
    Text = "Gems: " .. tostring(statsData.totalGems)
})

-- BP XP Label
local bpXPLabel = sections.StatsSection1:Label({
    Text = "BP XP: " .. tostring(statsData.totalBPXP)
})

sections.StatsSection1:Header({
    Name = "Performance"
})

-- Damage Label
local damageLabel = sections.StatsSection1:Label({
    Text = "Total Damage: " .. tostring(statsData.totalDamage)
})

-- Kills Label
local killsLabel = sections.StatsSection1:Label({
    Text = "Titans Killed: " .. tostring(statsData.totalKills)
})

-- Crits Label
local critsLabel = sections.StatsSection1:Label({
    Text = "Critical Hits: " .. tostring(statsData.totalCrits)
})

-- Missions Label
local missionsLabel = sections.StatsSection1:Label({
    Text = "Missions/Raids Completed: " .. tostring(statsData.missions)
})

sections.StatsSection2:Header({
    Name = "Perks & Special Items"
})

-- Common Perks Label
local commonLabel = sections.StatsSection2:Label({
    Text = "Common Perks: " .. tostring(statsData.totalCommonPerks)
})

-- Rare Perks Label
local rareLabel = sections.StatsSection2:Label({
    Text = "Rare Perks: " .. tostring(statsData.totalRarePerks)
})

-- Epic Perks Label
local epicLabel = sections.StatsSection2:Label({
    Text = "Epic Perks: " .. tostring(statsData.totalEpicPerks)
})

-- Legendary Perks Label
local legendaryLabel = sections.StatsSection2:Label({
    Text = "Legendary Perks: " .. tostring(statsData.totalLegendaryPerks)
})

-- Prestige Scrolls Label
local prestigeLabel = sections.StatsSection2:Label({
    Text = "Prestige Scrolls: " .. tostring(statsData.totalPrestigeScrolls)
})

-- Mythical Perks Label
local mythicalLabel = sections.StatsSection2:Label({
    Text = "Mythical Perks: " .. tostring(statsData.totalMythicalPerks)
})

-- Serum Label
local serumLabel = sections.StatsSection2:Label({
    Text = "Serum: " .. tostring(statsData.totalSerum)
})

-- Last Updated Label
local lastUpdatedLabel = sections.StatsSection2:Label({
    Text = "Last Updated: " .. (statsData.lastUpdated ~= "" and statsData.lastUpdated or "Never")
})

-- Reset Stats Button
sections.StatsSection2:Button({
    Name = "Reset Stats",
    Callback = function()
        Window:Dialog({
            Title = "Reset Stats",
            Description = "Are you sure you want to reset all stats? This cannot be undone.",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        -- Reset all stats to 0
                        for key, _ in pairs(statsData) do
                            if key ~= "lastUpdated" then
                                statsData[key] = 0
                            end
                        end
                        statsData.lastUpdated = os.date("%d-%b-%Y %I:%M %p")
                        
                        -- Update UI using the updateStatsUI function with null checks
                        updateStatsUI()
                        
                        -- Save to file
                        saveStats()
                        
                        Window:Notify({
                            Title = "Stats Reset",
                            Description = "All stats have been reset to zero.",
                            Lifetime = 5
                        })
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Function to update UI with current stats
local function updateStatsUI()
    -- Add null checks and type verification for each UI element
    if goldLabel and typeof(goldLabel.SetText) == "function" then
        goldLabel:SetText("Gold: " .. tostring(statsData.totalGold))
    end
    
    if xpLabel and typeof(xpLabel.SetText) == "function" then
        xpLabel:SetText("XP: " .. tostring(statsData.totalXP))
    end
    
    if gemsLabel and typeof(gemsLabel.SetText) == "function" then
        gemsLabel:SetText("Gems: " .. tostring(statsData.totalGems))
    end
    
    if bpXPLabel and typeof(bpXPLabel.SetText) == "function" then
        bpXPLabel:SetText("BP XP: " .. tostring(statsData.totalBPXP))
    end
    
    if damageLabel and typeof(damageLabel.SetText) == "function" then
        damageLabel:SetText("Total Damage: " .. tostring(statsData.totalDamage))
    end
    
    if killsLabel and typeof(killsLabel.SetText) == "function" then
        killsLabel:SetText("Titans Killed: " .. tostring(statsData.totalKills))
    end
    
    if critsLabel and typeof(critsLabel.SetText) == "function" then
        critsLabel:SetText("Critical Hits: " .. tostring(statsData.totalCrits))
    end
    
    if missionsLabel and typeof(missionsLabel.SetText) == "function" then
        missionsLabel:SetText("Missions/Raids Completed: " .. tostring(statsData.missions))
    end
    
    if commonLabel and typeof(commonLabel.SetText) == "function" then
        commonLabel:SetText("Common Perks: " .. tostring(statsData.totalCommonPerks))
    end
    
    if rareLabel and typeof(rareLabel.SetText) == "function" then
        rareLabel:SetText("Rare Perks: " .. tostring(statsData.totalRarePerks))
    end
    
    if epicLabel and typeof(epicLabel.SetText) == "function" then
        epicLabel:SetText("Epic Perks: " .. tostring(statsData.totalEpicPerks))
    end
    
    if legendaryLabel and typeof(legendaryLabel.SetText) == "function" then
        legendaryLabel:SetText("Legendary Perks: " .. tostring(statsData.totalLegendaryPerks))
    end
    
    if prestigeLabel and typeof(prestigeLabel.SetText) == "function" then
        prestigeLabel:SetText("Prestige Scrolls: " .. tostring(statsData.totalPrestigeScrolls))
    end
    
    if mythicalLabel and typeof(mythicalLabel.SetText) == "function" then
        mythicalLabel:SetText("Mythical Perks: " .. tostring(statsData.totalMythicalPerks))
    end
    
    if serumLabel and typeof(serumLabel.SetText) == "function" then
        serumLabel:SetText("Serum: " .. tostring(statsData.totalSerum))
    end
    
    if lastUpdatedLabel and typeof(lastUpdatedLabel.SetText) == "function" then
        lastUpdatedLabel:SetText("Last Updated: " .. statsData.lastUpdated)
    end
end

-- Function to safely convert string to number
local function safeToNumber(str)
    if not str or str == "" then return 0 end
    
    -- Remove any non-digit characters except decimal point
    local cleanStr = str:gsub("[^%d%.]", "")
    
    -- Handle potential errors
    local success, result = pcall(function()
        return tonumber(cleanStr)
    end)
    
    if not success or not result then
        -- Debug print removed
        return 0
    end
    
    return result
end

-- Add a manual update button
sections.StatsSection2:Button({
    Name = "Force Update Stats",
    Callback = function()
        local success = updateStatsFromRewards()
        if success then
            Window:Notify({
                Title = "Stats Updated",
                Description = "Stats have been updated from the current rewards screen.",
                Lifetime = 5
            })
        else
            Window:Notify({
                Title = "Update Failed",
                Description = "No rewards screen detected or no new data found.",
                Lifetime = 5
            })
        end
    end,
})

-- Function to update stats from rewards screen with improved error handling
local function updateStatsFromRewards()
    -- Debug print removed
    
    -- Check if rewards screen is visible
    local retryBtn = getRetryButton()
    local items, stats = getItems()
    
    if not isActuallyVisible(retryBtn) then
        -- Debug print removed
        return false
    end
    
    if not stats then
        -- Debug print removed
        return false
    end
    
    -- Get mission time to check if this is a new mission
    local currentTime = getText("Interface.Rewards.Main.Info.Main.Stats.Time_Taken.Amount")
    -- Debug print removed
    
    if currentTime == "0" or currentTime == lastMissionTime then
        -- Debug print removed
        return false
    end
    
    -- Debug print removed: New mission detected
    lastMissionTime = currentTime

    -- Get all reward values with error checking - Updated perk names
    local gold = getText("Interface.Rewards.Main.Info.Main.Items.Gold.Main.Inner.Quantity")
    local xp = getText("Interface.Rewards.Main.Info.Main.Items.XP.Main.Inner.Quantity")
    local bp_xp = getText("Interface.Rewards.Main.Info.Main.Items.BP_XP.Main.Inner.Quantity")
    local gems = getText("Interface.Rewards.Main.Info.Main.Items.Gems.Main.Inner.Quantity")
    local serum = getText("Interface.Rewards.Main.Info.Main.Items.Serum.Main.Inner.Quantity")
    local common = getText("Interface.Rewards.Main.Info.Main.Items.Common_Perk.Main.Inner.Quantity")
    local rare = getText("Interface.Rewards.Main.Info.Main.Items.Rare_Perk.Main.Inner.Quantity")
    local epic = getText("Interface.Rewards.Main.Info.Main.Items.Epic_Perk.Main.Inner.Quantity")
    local legendary = getText("Interface.Rewards.Main.Info.Main.Items.Legendary_Perk.Main.Inner.Quantity")
    local prestige = getText("Interface.Rewards.Main.Info.Main.Items.Prestige_Scroll.Main.Inner.Quantity")
    local mythical = getText("Interface.Rewards.Main.Info.Main.Items.Mythical_Perk.Main.Inner.Quantity")

    local damage = getText("Interface.Rewards.Main.Info.Main.Stats.Damage_Dealt.Amount")
    local kills = getText("Interface.Rewards.Main.Info.Main.Stats.Titans_Killed.Amount")
    local crits = getText("Interface.Rewards.Main.Info.Main.Stats.Critical_Hits.Amount")

    local timeString = os.date("%d-%b-%Y %I:%M %p")
    
    -- Debug prints removed
    
    -- Update stats data with new values
    local oldGold = statsData.totalGold
    statsData.totalGold = statsData.totalGold + safeToNumber(gold)
    statsData.totalXP = statsData.totalXP + safeToNumber(xp)
    statsData.totalGems = statsData.totalGems + safeToNumber(gems)
    statsData.totalBPXP = statsData.totalBPXP + safeToNumber(bp_xp)
    statsData.totalDamage = statsData.totalDamage + safeToNumber(damage)
    statsData.totalKills = statsData.totalKills + safeToNumber(kills)
    statsData.totalCrits = statsData.totalCrits + safeToNumber(crits)
    statsData.totalCommonPerks = statsData.totalCommonPerks + safeToNumber(common)
    statsData.totalRarePerks = statsData.totalRarePerks + safeToNumber(rare)
    statsData.totalEpicPerks = statsData.totalEpicPerks + safeToNumber(epic)
    statsData.totalLegendaryPerks = statsData.totalLegendaryPerks + safeToNumber(legendary)
    statsData.totalPrestigeScrolls = statsData.totalPrestigeScrolls + safeToNumber(prestige)
    statsData.totalMythicalPerks = statsData.totalMythicalPerks + safeToNumber(mythical)
    statsData.totalSerum = statsData.totalSerum + safeToNumber(serum)
    statsData.missions = statsData.missions + 1
    statsData.lastUpdated = timeString
    
    -- Verify that stats were actually updated
    if statsData.totalGold == oldGold then
        -- Debug print removed: Stats don't appear to have changed warning
    end
    
    -- Update UI
    updateStatsUI()
    
    -- Save stats to file
    local saveSuccess = saveStats()
    if not saveSuccess then
        print("[ERROR] updateStatsFromRewards: Failed to save stats after update")
    end
    
    -- Send webhook with rewards data if enabled
    if sendWebhook and webhookURL ~= "" then
        -- Check if we should ping for special items (including legendary perks)
        local shouldPing = pingOnSpecial and ((tonumber(serum) or 0) > 0 or (tonumber(mythical) or 0) > 0 or (tonumber(legendary) or 0) > 0)
        
        -- Build the description with updated perk information
        local description = string.format(
            "**User:** %s\n\n" ..
            "**Totals:**\n" ..
            "Level: %d\n" ..
            "Gold: %s\n" ..
            "Gems: %s\n\n" ..
            "**Stats:**\n" ..
            "%s Time Taken\n" ..
            "%s Damage Dealt\n" ..
            "%s Titan Kills\n" ..
            "%s Critical Hits\n\n" ..
            "**Rewards:**\n" ..
            "%s Gold\n" ..
            "%s XP\n" ..
            "%s Gems\n\n" ..
            "**Drops:**\n" ..
            "%s BP XP\n" ..
            "%s Common Perk\n" ..
            "%s Rare Perk\n" ..
            "%s Epic Perk\n" ..
            "%s Legendary Perk\n\n" ..
            "**Special Rewards:**\n" ..
            "%s Serum\n" ..
            "%s Mythical Perk",
            showUsername and player.Name or "Disabled",
            statsData.missions,
            tostring(statsData.totalGold),
            tostring(statsData.totalGems),
            currentTime,
            damage,
            kills,
            crits,
            gold,
            xp,
            gems,
            bp_xp,
            common,
            rare,
            epic,
            legendary,
            serum,
            mythical
        )

        local embed = {
            title = "LunarZ Rewards Logger",
            description = description,
            thumbnail = { url = thumbnailURL },
            color = 9936031	, -- Blue color to match the image
            footer = { text = "Sent at: " .. timeString }
        }

        local data = {
            content = shouldPing and "@everyone" or nil,
            embeds = {embed}
        }

        local success, response = pcall(function()
            return request({
                Url = webhookURL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode(data)
            })
        end)
        
        if success then
            -- Debug print removed: Webhook sent successfully
        else
            -- Debug print removed: Failed to send webhook
        end
    end
    
    -- Debug print removed: Stats updated successfully
    return true
end

-- Stats update loop with improved error handling
task.spawn(function()
    -- Debug print removed: Starting stats tracking loop
    local consecutiveErrors = 0
    
    while true do
        local success, err = pcall(function()
            local statsUpdated = updateStatsFromRewards()
            if statsUpdated then
                consecutiveErrors = 0 -- Reset error counter on success
                -- Debug print removed: Stats successfully updated from rewards
            end
        end)
        
        if not success then
            consecutiveErrors = consecutiveErrors + 1
            print("[ERROR] Error in stats update loop: " .. tostring(err))
            
            -- If we get too many consecutive errors, slow down the loop
            if consecutiveErrors > 5 then
                print("[WARNING] Multiple consecutive errors in stats tracking. Slowing down update frequency.")
                task.wait(5) -- Wait longer between attempts after multiple failures
            else
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end
end)

sections.VisualSection1:Toggle({
    Name = "Titan ESP",
    Default = false,
    Callback = function(Value)
        if Value then
            local titansFolder = game.Workspace:FindFirstChild("Titans")
            if not titansFolder then
                Fluent:Notify({
                    Title = "Error",
                    Content = "Titans folder not found. Are you in a mission?",
                    Duration = 3
                })
                return
            end
            
            for _, titan in pairs(titansFolder:GetChildren()) do
                -- Check if highlight already exists
                if not titan:FindFirstChild("Highlight") then
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = titan
                    highlight.Archivable = true
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Enabled = true
                    highlight.FillColor = Color3.fromRGB(255, 0, 4)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                end
            end
            
            -- Connect to ChildAdded to highlight new titans
            game.Workspace.Titans.ChildAdded:Connect(function(titan)
                if sections.MainSection1.TitanESP then -- Updated reference
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = titan
                    highlight.Archivable = true
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Enabled = true
                    highlight.FillColor = Color3.fromRGB(255, 0, 4)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                end
            end)
        else
            -- Remove highlights when toggled off
            local titansFolder = game.Workspace:FindFirstChild("Titans")
            if titansFolder then
                for _, titan in pairs(titansFolder:GetChildren()) do
                    local highlight = titan:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end,
}, "TitanESP")

-- ESP Color Picker
sections.VisualSection1:Colorpicker({
    Name = "ESP Color",
    Default = Color3.fromRGB(255, 0, 4),
    Callback = function(Value)
        local titansFolder = game.Workspace:FindFirstChild("Titans")
        if titansFolder then
            for _, titan in pairs(titansFolder:GetChildren()) do
                local highlight = titan:FindFirstChild("Highlight")
                if highlight then
                    highlight.FillColor = Value
                end
            end
        end
    end,
}, "ESPColor")

-- Optimize Game Toggle
sections.VisualSection1:Toggle({
    Name = "Optimize Game",
    Default = false,
    Callback = function(Value)
        if Value then
            local decalsyeeted = true
            local g = game
            local w = g.Workspace
            local l = g.Lighting
            local t = w.Terrain
            
            t.WaterWaveSize = 0
            t.WaterWaveSpeed = 0
            t.WaterReflectance = 0
            t.WaterTransparency = 0
            l.GlobalShadows = false
            l.FogEnd = 9e9
            l.Brightness = 0
            settings().Rendering.QualityLevel = "Level01"
            
            for i, v in pairs(g:GetDescendants()) do
                if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
                    v.Transparency = 1
                elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                    v.Lifetime = NumberRange.new(0)
                elseif v:IsA("Explosion") then
                    v.BlastPressure = 1
                    v.BlastRadius = 1
                elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
                    v.Enabled = false
                elseif v:IsA("MeshPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                    v.TextureID = 10385902758728957
                end
            end
            
            for i, e in pairs(l:GetChildren()) do
                if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
                    e.Enabled = false
                end
            end
        end
    end,
}, "OptimizeGame")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local hiddenFolder = ReplicatedStorage:FindFirstChild("aristo_deletemap")
if not hiddenFolder then
    hiddenFolder = Instance.new("Folder")
    hiddenFolder.Name = "aristo_deletemap"
    hiddenFolder.Parent = ReplicatedStorage
end

sections.VisualSection1:Toggle({
    Name = "Delete Map",
    Default = false,
    Callback = function(state)
        if state then
            -- إخفاء Climbable ونضع مجلد وهمي بنفس الاسم
            local climbable = workspace:FindFirstChild("Climbable")
            if climbable then
                -- مجلد وهمي لتفادي مشكلة WaitForChild
                local fakeClimbable = Instance.new("Folder")
                fakeClimbable.Name = "Climbable"
                fakeClimbable.Parent = workspace
                climbable.Parent = hiddenFolder
            else
                -- Climbable not found
            end
            -- إخفاء العناصر غير المهمة داخل Unclimbable
            local unclimbable = workspace:FindFirstChild("Unclimbable")
            if unclimbable then
                for _, child in ipairs(unclimbable:GetChildren()) do
                    if child.Name ~= "Reloads" and child.Name ~= "Objective" and child.Name ~= "Cutscene" then
                        pcall(function()
                            child.Parent = hiddenFolder
                        end)
                    end
                end
            else
                -- Unclimbable not found
            end
            -- تعطيل Collider داخل Objective
            local objective = unclimbable and unclimbable:FindFirstChild("Objective")
            if objective then
                local guard = objective:FindFirstChild("Guard")
                if guard then
                    local collider = guard:FindFirstChild("Collider")
                    if collider and collider:IsA("BasePart") then
                        collider.CanTouch = false
                        collider.CanCollide = false
                        collider.Transparency = 1
                    end
                end
            end
        else
            -- Toggle disabled
        end
    end,
}, "del")

MacLib:SetFolder("Maclib")
tabs.Settings:InsertConfigSection("Left")

Window.onUnloaded(function()
	print("LunarZ Loaded!")
end)

tabs.Main:Select()
MacLib:LoadAutoLoadConfig()
