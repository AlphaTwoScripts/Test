local MacLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/AlphaTwoScripts/BOOMA/refs/heads/main/LunarZ-UI"))()

-- Detect if user is on mobile
local UserInputService = game:GetService("UserInputService")
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Set window size based on device
local windowSize
if isMobile then
    windowSize = UDim2.fromOffset(570, 360)  -- Mobile size
else
    windowSize = UDim2.fromOffset(750, 540)  -- PC size
end

local Window = MacLib:Window({
	Title = "LunarZ",
	Subtitle = "AOT:R | FREE",
	Size = windowSize,
	DragStyle = 1,
	DisabledWindowControls = {},
	ShowUserInfo = true,
	Keybind = Enum.KeyCode.RightControl,
	AcrylicBlur = true,
})

local globalSettings = {
	UIBlurToggle = Window:GlobalSetting({
		Name = "UI Blur",
		Default = Window:GetAcrylicBlurState(),
		Callback = function(bool)
			Window:SetAcrylicBlurState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " UI Blur",
				Lifetime = 5
			})
		end,
	}),
	NotificationToggler = Window:GlobalSetting({
		Name = "Notifications",
		Default = Window:GetNotificationsState(),
		Callback = function(bool)
			Window:SetNotificationsState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Enabled" or "Disabled") .. " Notifications",
				Lifetime = 5
			})
		end,
	}),
	ShowUserInfo = Window:GlobalSetting({
		Name = "Show User Info",
		Default = Window:GetUserInfoState(),
		Callback = function(bool)
			Window:SetUserInfoState(bool)
			Window:Notify({
				Title = Window.Settings.Title,
				Description = (bool and "Showing" or "Redacted") .. " User Info",
				Lifetime = 5
			})
		end,
	})
}

local tabGroups = {
	TabGroup1 = Window:TabGroup()
}

local tabs = {
	Main = tabGroups.TabGroup1:Tab({ Name = "Main", Image = "rbxassetid://86591853167234" }),
	Raids = tabGroups.TabGroup1:Tab({ Name = "Raids", Image = "rbxassetid://115443066665979" }),
	Stats = tabGroups.TabGroup1:Tab({ Name = "Stats", Image = "rbxassetid://95014688478272" }),
	Webhook = tabGroups.TabGroup1:Tab({ Name = "Webhook", Image = "rbxassetid://70774834798137" }),
	Visual = tabGroups.TabGroup1:Tab({ Name = "Visual", Image = "rbxassetid://100148515061030" }),
	Teleport = tabGroups.TabGroup1:Tab({ Name = "Teleport", Image = "rbxassetid://6723742952" }),
	Settings = tabGroups.TabGroup1:Tab({ Name = "Settings", Image = "rbxassetid://10734950309" }),
}

local sections = {
	MainSection1 = tabs.Main:Section({ Side = "Left" }),
	MainSection2 = tabs.Main:Section({ Side = "Right" }),
	RaidsSection1 = tabs.Raids:Section({ Side = "Left" }),
	StatsSection1 = tabs.Stats:Section({ Side = "Left" }),
	StatsSection2 = tabs.Stats:Section({ Side = "Right" }),
	WebhookSection1 = tabs.Webhook:Section({ Side = "Left" }),
	VisualSection1 = tabs.Visual:Section({ Side = "Left" }),
	TeleportSection1 = tabs.Teleport:Section({ Side = "Left" }),
}

sections.MainSection1:Header({
	Name = "Farm"
})

sections.MainSection2:Header({
	Name = "Misc"
})

-- Function for the Nape Extender feature
local function extendNape()
    while Options.NapeExtender.Value do
        
        -- Check if Titans folder exists
                local titansFolder = game:GetService("Workspace"):FindFirstChild("Titans")
                if not titansFolder then
                    print("Titans folder not found. Wait and retry...")
                    task.wait(1)
                    continue
                end
        
        for i, titans in pairs(titansFolder:GetChildren()) do
            local stepone = titans:FindFirstChild("Hitboxes")
            if stepone then
                local steptwo = stepone:FindFirstChild("Hit")
                if steptwo then
                    local final = steptwo:FindFirstChild("Nape")
                    if final then
                        final.Size = Vector3.new(Options.HitboxSize.Value, Options.HitboxSize.Value, Options.HitboxSize.Value)
                        final.Transparency = 0.85
                        final.CanCollide = false
                    end
                end
            end
        end
        wait(0.05)
    end
end

-- Add features to the Features tab based on game state
if not isInMainMenu then
    -- Add Nape Extender toggle
    sections.MainSection1:Toggle({ 
        Name = "Nape Extender (Risky)",
        Default = false,
        Callback = function(Value)
            if Value then
                task.spawn(extendNape)
            end
        end
    }, "NapeExtender")

    -- Add a hitbox size slider to Features tab
    sections.MainSection1:Slider({ 
        Name = "Hitbox Size",
        Default = 250,
        Minimum = 10,
        Maximum = 500,
        DisplayMethod = "Number",
        Precision = 0,
        Callback = function(Value)
            -- This value will be used in the Nape Extender function
            print("Hello", Value)
        end
    }, "HitboxSize")
end


local AutoEscapeEnabled = sections.MainSection2:Toggle({
    Name = "Auto Escape",
    Default = false,
    Callback = function(Value)
        -- Auto Escape Script
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local player = game.Players.LocalPlayer
        local gui = player:WaitForChild("PlayerGui")
        local POST = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST")
        
        local escapeRunning = Value
        local lastEscapeButton = nil
        
        if escapeRunning then
            -- Create a new connection when enabled
            _G.EscapeThread = task.spawn(function()
                while escapeRunning do
                    local interface = gui:FindFirstChild("Interface")
                    local buttons = interface and interface:FindFirstChild("Buttons")

                    if buttons then
                        local currentButtons = buttons:GetChildren()

                        if #currentButtons > 0 then
                            local newestButton = currentButtons[1]

                            if newestButton ~= lastEscapeButton then
                                lastEscapeButton = newestButton

                                POST:FireServer("Attacks", "Slash_Escape")
                            end
                        else
                            lastEscapeButton = nil
                        end
                    else
                        lastEscapeButton = nil
                    end

                    task.wait(0.1)
                end
            end)
            
            -- Optional: Add the cleanup thread if you want to remove buttons after processing
            _G.CleanGUIThread = task.spawn(function()
                while escapeRunning do
                    local interface = gui:FindFirstChild("Interface")
                    local buttons = interface and interface:FindFirstChild("Buttons")

                    if buttons then
                        for _, btn in pairs(buttons:GetChildren()) do
                            btn:Destroy()
                        end
                    end

                    task.wait(0.1)
                end
            end)
        else
            -- Stop the loops when disabled
            escapeRunning = false
            lastEscapeButton = nil
            
            if _G.EscapeThread then
                task.cancel(_G.EscapeThread)
                _G.EscapeThread = nil
            end
            
            if _G.CleanGUIThread then
                task.cancel(_G.CleanGUIThread)
                _G.CleanGUIThread = nil
            end
        end
    end
}, "AutoEscapeEnabled")

sections.MainSection2:Toggle({
	Name = "Anti Injuries",
	Default = false,
	Callback = function(state)
		if state then
			local Players = game:GetService("Players")
			local player = Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:Wait()
			local injuriesFolder = char:WaitForChild("Injuries", 10)
			if not injuriesFolder then
				warn(".")
				return
			end
			for _, injury in pairs(injuriesFolder:GetChildren()) do
				injury:Destroy()
			end
			getgenv().AntiInjuryConnection = injuriesFolder.ChildAdded:Connect(function(child)
				task.wait()
				child:Destroy()
			end)
		else
			if getgenv().AntiInjuryConnection then
				getgenv().AntiInjuryConnection:Disconnect()
				getgenv().AntiInjuryConnection = nil
			end
		end
	end,
}, "AntiInjuriesToggle")

local VIP = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local autoRetryEnabled = false
local mobileKillerConn
local isNavigating = false -- prevent multiple navigation attempts

-- More robust UI element checking
local function getUIElements()
    local interface = player:FindFirstChild("PlayerGui") 
        and player.PlayerGui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local rewardsMain = rewards and rewards:FindFirstChild("Main")
    local retryBtn = rewardsMain
        and rewardsMain:FindFirstChild("Info")
        and rewardsMain.Info:FindFirstChild("Main")
        and rewardsMain.Info.Main:FindFirstChild("Buttons")
        and rewardsMain.Info.Main.Buttons:FindFirstChild("Retry")
    
    return interface, rewards, rewardsMain, retryBtn
end

local function shouldClickRetry()
    local interface, rewards, rewardsMain, retryBtn = getUIElements()
    
    return retryBtn
       and rewards.Visible
       and rewardsMain.Visible
       and retryBtn.Visible
       and retryBtn.AbsoluteSize.Magnitude > 10
       and not isNavigating -- prevent multiple attempts
end

-- Wait for a condition with timeout
local function waitForCondition(condition, timeout)
    local startTime = tick()
    while tick() - startTime < timeout do
        if condition() then
            return true
        end
        RunService.Heartbeat:Wait()
    end
    return false
end

-- Send key event - press only (for navigation keys)
local function sendKeyPress(keyCode)
    VIP:SendKeyEvent(true, keyCode, false, game)
end

-- Send key event with press and release (for action keys like Enter)
local function sendKeyPressRelease(keyCode)
    VIP:SendKeyEvent(true, keyCode, false, game)
    task.wait(0.1)
    VIP:SendKeyEvent(false, keyCode, false, game)
end

local function navigateToRetry()
    if isNavigating then return end
    isNavigating = true
    
    print("Starting navigation to retry button...")
    
    -- Step 1: BackSlash to open menu (press only)
    sendKeyPress(Enum.KeyCode.BackSlash)
    
    -- Wait for menu to appear (check if navigation worked)
    local success = waitForCondition(function()
        -- Add your own condition here to check if the menu opened
        -- For example, check if a specific menu element is visible
        return true -- placeholder
    end, 2)
    
    if not success then
        print("Menu didn't open, aborting navigation")
        isNavigating = false
        return
    end
    
    task.wait(0.5) -- Match your original timing
    
    -- Step 2: Navigate right twice (press only)
    sendKeyPress(Enum.KeyCode.Right)
    task.wait(0.5)
    sendKeyPress(Enum.KeyCode.Right)
    task.wait(0.5)
    
    -- Step 3: Press Enter (press + release like your original)
    sendKeyPressRelease(Enum.KeyCode.Return)
    
    print("Navigation sequence completed")
    isNavigating = false
end

-- Main loop with better error handling
task.spawn(function()
    while true do
        if autoRetryEnabled then
            local success, err = pcall(function()
                if shouldClickRetry() then
                    navigateToRetry()
                    task.wait(3.5) -- Cooldown after navigation
                end
            end)
            
            if not success then
                warn("Auto retry error: " .. tostring(err))
                isNavigating = false -- Reset navigation state on error
            end
        end
        task.wait(0.5)
    end
end)

-- Mobile killer with better cleanup
local function setupMobileKiller()
    if mobileKillerConn then
        mobileKillerConn:Disconnect()
    end
    
    mobileKillerConn = RunService.Heartbeat:Connect(function()
        local interface = player:FindFirstChild("PlayerGui")
                    and player.PlayerGui:FindFirstChild("Interface")
        if interface then
            local mobile = interface:FindFirstChild("Mobile")
            if mobile then
                mobile:Destroy()
            end
        end
    end)
end

-- Toggle button
local AutoRetryToggle = sections.MainSection2:Toggle({
    Name = "Auto Retry",
    Default = false,
    Callback = function(state)
        autoRetryEnabled = state
        isNavigating = false -- Reset navigation state
        
        if state then
            print("Auto Retry enabled")
            
            -- Immediately destroy existing Mobile
            local interface = player:FindFirstChild("PlayerGui")
                        and player.PlayerGui:FindFirstChild("Interface")
            if interface then
                local mobile = interface:FindFirstChild("Mobile")
                if mobile then
                    mobile:Destroy()
                end
            end
            
            -- Setup continuous mobile killer
            setupMobileKiller()
        else
            print("Auto Retry disabled")
            
            -- Clean up mobile killer
            if mobileKillerConn then
                mobileKillerConn:Disconnect()
                mobileKillerConn = nil
            end
        end
    end
}, "AutoRetryToggle")


local Players = game:GetService("Players")
local PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui") -- ✅ Fixed reference
local POST = game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST")
local autoRefillActive = false
-- Auto refill functions
local function isBladesZero()
    local sets = PlayerGui:FindFirstChild("Interface")
        and PlayerGui.Interface:FindFirstChild("HUD")
        and PlayerGui.Interface.HUD:FindFirstChild("Main")
        and PlayerGui.Interface.HUD.Main:FindFirstChild("Top")
        and PlayerGui.Interface.HUD.Main.Top:FindFirstChild("Blades")
        and PlayerGui.Interface.HUD.Main.Top.Blades:FindFirstChild("Sets")
    if sets and sets:IsA("TextLabel") then
        return tonumber(sets.Text:match("^(%d+)") or "0") == 0
    end
    return false
end
local function isSpearsZero()
    local lbl = PlayerGui:FindFirstChild("Interface")
        and PlayerGui.Interface:FindFirstChild("HUD")
        and PlayerGui.Interface.HUD:FindFirstChild("Main")
        and PlayerGui.Interface.HUD.Main:FindFirstChild("Top")
        and PlayerGui.Interface.HUD.Main.Top:FindFirstChild("Spears")
        and PlayerGui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears")
    if lbl and lbl:IsA("TextLabel") then
        return tonumber(lbl.Text:match("^(%d+)") or "0") == 0
    end
    return false
end
local function getRefillPoint()
    local reloads = workspace:FindFirstChild("Unclimbable") and workspace.Unclimbable:FindFirstChild("Reloads")
    if reloads then
        for _, obj in ipairs(reloads:GetChildren()) do
            if obj:FindFirstChild("Refill") then
                return obj.Refill
            end
        end
    end
    return nil
end
-- Auto refill loop
task.spawn(function()
    while true do
        task.wait(0.1)
        if not autoRefillActive then continue end

        local bladesZero = isBladesZero()
        local spearsZero = isSpearsZero()
        local refill = getRefillPoint()

        if refill then
            if bladesZero then
                POST:FireServer("Attacks", "Reload", refill)
            end
            if spearsZero then
                POST:FireServer("Attacks", "Reload", refill)
            end
        end
    end
end)
sections.MainSection2:Toggle({
    Name = "Auto Refill",
    Default = false,
    Callback = function(value)
        autoRefillActive = value
    end,
}, "AutoRefillToggle")


-- Services
local VIM        = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local Players    = game:GetService("Players")

-- State
local autoReloadActive = false
local reloadConnection = nil
local lastReloadTime   = 0
local RELOAD_COOLDOWN  = 10  -- seconds

-- Utility: press R with a tiny delay
local function pressR()
    VIM:SendKeyEvent(true, Enum.KeyCode.R, false, game)   -- key down
    task.wait(0.05)
    VIM:SendKeyEvent(false, Enum.KeyCode.R, false, game)  -- key up
end

-- Set up the auto‑reload loop
local function setupAutoReload()
    -- Clean up any previous connection
    if reloadConnection then
        reloadConnection:Disconnect()
        reloadConnection = nil
    end

    if not autoReloadActive then
        return
    end

    local player = Players.LocalPlayer

    reloadConnection = RunService.Heartbeat:Connect(function()
        if not autoReloadActive then
            return
        end

        -- Character check
        local character = workspace.Characters:FindFirstChild(player.Name)
        if not character then return end

        local rig = character:FindFirstChild("Rig_" .. player.Name)
        if not rig then return end

        -- Find blades
        local rightBlade = rig:FindFirstChild("RightHand")
                            and rig.RightHand:FindFirstChild("Blade_1")
        local leftBlade  = rig:FindFirstChild("LeftHand")
                            and rig.LeftHand:FindFirstChild("Blade_1")

        -- If any blade is fully transparent and cooldown passed
        if ((rightBlade  and rightBlade.Transparency  == 1) or
            (leftBlade   and leftBlade.Transparency   == 1))
           and (tick() - lastReloadTime >= RELOAD_COOLDOWN) then
            pressR()
            lastReloadTime = tick()
        end
    end)
end

-- Toggle setup
sections.MainSection2:Toggle({
    Name    = "Auto Reload",
    Default = false,
    Callback = function(value)
        autoReloadActive = value
        if value then
            setupAutoReload()
        elseif reloadConnection then
            reloadConnection:Disconnect()
            reloadConnection = nil
        end
    end,
}, "AutoBladeReloadToggle")


local Players = game:GetService("Players")
local player = Players.LocalPlayer
local interface = player:WaitForChild("PlayerGui"):WaitForChild("Interface")
local damageConnection

sections.MainSection2:Toggle({
    Name = "Remove Dmg Text",
    Default = false,
    Callback = function(value)
        if value then
            for _, obj in pairs(interface:GetDescendants()) do
                if obj:IsA("TextLabel") and obj.Name == "Number" then
                    obj.Visible = false
                end
            end
            damageConnection = interface.DescendantAdded:Connect(function(obj)
                if obj:IsA("TextLabel") and obj.Name == "Number" then
                    obj.Visible = false
                end
            end)
        else
            if damageConnection then
                damageConnection:Disconnect()
                damageConnection = nil
            end
        end
    end
}, "RemoveDmgTextToggle")

-- Auto Close UI Toggle
local autoCloseEnabled = false
local autoCloseConnection = nil
local autoCloseTime = 15 -- seconds

sections.MainSection2:Toggle({
	Name = "Auto Close UI (" .. autoCloseTime .. "s)",
	Default = false,
	Callback = function(value)
		autoCloseEnabled = value
		
		if autoCloseEnabled then
			-- Start the auto close timer
			autoCloseConnection = coroutine.create(function()
				wait(autoCloseTime)
				if autoCloseEnabled then
					-- Hide/close the window
					Window:Unload() -- This should close/destroy the window in MacLib
					
					Window:Notify({
						Title = Window.Settings.Title,
						Description = "UI automatically closed after " .. autoCloseTime .. " seconds",
						Lifetime = 5
					})
				end
			end)
			coroutine.resume(autoCloseConnection)
			
			Window:Notify({
				Title = Window.Settings.Title,
				Description = "Auto close enabled - UI will close in " .. autoCloseTime .. " seconds",
				Lifetime = 3
			})
		else
			-- Cancel the auto close timer
			if autoCloseConnection then
				autoCloseConnection = nil
			end
			
			Window:Notify({
				Title = Window.Settings.Title,
				Description = "Auto close disabled",
				Lifetime = 3
			})
		end
	end,
}, "AutoCloseToggle")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local noclipConnection

sections.MainSection2:Toggle({
    Name = "Noclip",
    Default = false,
    Callback = function(value)
        if value then
            noclipConnection = RunService.Stepped:Connect(function()
                if lp.Character then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end,
}, "NoClipToggle")

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local interface = player:WaitForChild("PlayerGui"):WaitForChild("Interface")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VirtualInput = game:GetService("VirtualInputManager")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local retryRemote = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET")

local TeleportService = game:GetService("TeleportService")

local isFlying = false
local bodyPos

local LocalPlayer = Players.LocalPlayer

local startDelay = 2 -- Fixed at 2 seconds

--//==============================\\--
--||      👑 AUTO KILL TITANS     ||--
--\\==============================//--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

local POST = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("POST")

local player = Players.LocalPlayer
local hrp = player.Character or player.CharacterAdded:Wait()
hrp = hrp:WaitForChild("HumanoidRootPart")
local gui = player:WaitForChild("PlayerGui")

local flySpeed = 250
local flyHeight = 125 -- Fixed at 125
local canHit = true
local isFlying = false
local moveMode = "Teleport"

-- 🔍 أقرب نيب
local function getClosestValidNape()
	local titansFolder = workspace:FindFirstChild("Titans")
	if not titansFolder then return nil end

	local priorityList = { "Attack_Titan", "Female_Titan" }

	for _, titanName in ipairs(priorityList) do
		local titan = titansFolder:FindFirstChild(titanName)
		if titan and titan:FindFirstChild("Humanoid") and titan.Humanoid.Health > 0 then
			local hitbox = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit")
			local nape = hitbox and hitbox:FindFirstChild("Nape")
			if nape and nape:IsA("BasePart") then
				return nape
			end
		end
	end

	local closest, dist = nil, math.huge
	for _, titan in ipairs(titansFolder:GetChildren()) do
		if table.find(priorityList, titan.Name) then continue end
		local hitboxes = titan:FindFirstChild("Hitboxes")
		if hitboxes then
			local hit = hitboxes:FindFirstChild("Hit")
			if hit then
				local nape = hit:FindFirstChild("Nape")
				local hum = titan:FindFirstChildWhichIsA("Humanoid")
				if nape and hum and hum.Health > 0 then
					local d = (hrp.Position - nape.Position).Magnitude
					if d < dist then
						closest = nape
						dist = d
					end
				end
			end
		end
	end

	return closest
end

-- 🚀 تنفيذ القتل
local function killFromAbove()
	task.wait(startDelay) -- 🕒 تأخير البداية

	RunService.Heartbeat:Connect(function()
		if not isFlying then return end

		local nape = getClosestValidNape()
		if not nape then return end

		local targetPos = nape.Position + Vector3.new(0, flyHeight, 0)

		if moveMode == "Hover" then
			local direction = (targetPos - hrp.Position).Unit
			hrp.AssemblyLinearVelocity = direction * flySpeed
		else
			hrp.CFrame = CFrame.new(targetPos)
		end

		if (hrp.Position - nape.Position).Magnitude <= 1520 and canHit then
			canHit = false

			coroutine.wrap(function()
				local randomDamage1 = math.random(250, 300)
				local accuracy = math.random(20, 30) / 100 -- من 0.20 إلى 0.30

				POST:FireServer("Hitboxes", "Register", nape, randomDamage1, accuracy)
				POST:FireServer("Attacks", "Slash", true)

				task.wait(0.25)
				canHit = true
			end)()
		end
	end)
end

-- ✅ New UI Elements in order: Slider, Dropdown, Toggle

-- ✅ Single slider for hover speed only
sections.MainSection1:Slider({
	Name = "Hover Speed",
	Default = 150,
	Minimum = 50,
	Maximum = 500,
	DisplayMethod = "Default",
	Precision = 0,
	Callback = function(Value)
		flySpeed = Value
	end
}, "HoverSpeed")

-- ✅ Dropdown for movement mode
local movementOptions = {"Teleport", "Hover"}

sections.MainSection1:Dropdown({
	Name = "Movement Mode",
	Multi = false,
	Required = true,
	Options = movementOptions,
	Default = 1,
	Callback = function(Value)
		moveMode = Value
	end,
}, "MovementMode")

-- ✅ Toggle for Auto Kill Titans
sections.MainSection1:Toggle({
	Name = "Auto Farm",
	Default = false,
	Callback = function(value)
		isFlying = value
		if isFlying then
			task.spawn(killFromAbove)
		end
	end,
}, "AutoKillTitans")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local gui = player:WaitForChild("PlayerGui")

local GET = ReplicatedStorage.Assets.Remotes.GET
local POST = ReplicatedStorage.Assets.Remotes.POST

local flyHeight = 200
local isHovering = false
local hoverPos = nil
local autoTSRunning = false
local startDelay = 2 -- Added missing startDelay variable

sections.MainSection1:Toggle({
	Name = "Auto Thunder Spears",
	Default = false,
	Callback = function(value)
		autoTSRunning = value
		
		if autoTSRunning then
			-- Start the auto-kill loop
			task.spawn(autoTS_KillLoop)
		else
			-- Stop hovering when disabled
			isHovering = false
			hoverPos = nil
		end
	end,
}, "AutoTitanSpearToggle")

-- 🔢 قراءة عدد Spears الحالي
local function getCurrentSpearSlot()
	local lbl = gui:FindFirstChild("Interface")
		and gui.Interface:FindFirstChild("HUD")
		and gui.Interface.HUD:FindFirstChild("Main")
		and gui.Interface.HUD.Main:FindFirstChild("Top")
		and gui.Interface.HUD.Main.Top:FindFirstChild("Spears")
		and gui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears")
	if lbl and lbl:IsA("TextLabel") then
		local current = tonumber(lbl.Text:match("^(%d+)") or "0")
		return tostring(current), current > 0
	end
	return "0", false
end

-- 📌 تحديد أقرب نيب مع أولوية لـ Female و Attack Titan، وإذا ما فيه يرجع العاديين
local function getClosestNapes(limit)
	local priority = { "Female_Titan", "Attack_Titan" }
	local selected = {}

	-- التايتنز المميزين
	for _, titan in ipairs(workspace.Titans:GetChildren()) do
		if table.find(priority, titan.Name) then
			local hum = titan:FindFirstChild("Humanoid")
			local hitbox = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit")
			local nape = hitbox and hitbox:FindFirstChild("Nape")
			if hum and hum.Health > 0 and nape and nape:IsA("BasePart") then
				for i = 1, limit do
					table.insert(selected, { part = nape, dist = (hrp.Position - nape.Position).Magnitude })
				end
			end
		end
	end

	if #selected > 0 then
		table.sort(selected, function(a, b) return a.dist < b.dist end)
		local out = {}
		for i = 1, math.min(limit, #selected) do
			table.insert(out, selected[i].part)
		end
		return out
	end

	-- إذا ما فيه تايتن مميز، نجيب العاديين
	for _, titan in ipairs(workspace.Titans:GetChildren()) do
		if not table.find(priority, titan.Name) then
			local hum = titan:FindFirstChild("Humanoid")
			local hitbox = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit")
			local nape = hitbox and hitbox:FindFirstChild("Nape")
			if hum and hum.Health > 0 and nape and nape:IsA("BasePart") then
				table.insert(selected, { part = nape, dist = (hrp.Position - nape.Position).Magnitude })
			end
		end
	end

	table.sort(selected, function(a, b) return a.dist < b.dist end)
	local out = {}
	for i = 1, math.min(limit, #selected) do
		table.insert(out, selected[i].part)
	end
	return out
end

-- ✨ الانتقال فوق النيب
local function teleportAbove(part)
	local targetPos = part.Position + Vector3.new(0, flyHeight, 0)
	local distance = (hrp.Position - targetPos).Magnitude

	if distance > 150 then
		character:PivotTo(CFrame.new(targetPos))
	else
		hrp.CFrame = CFrame.new(targetPos)
	end

	hoverPos = targetPos
	isHovering = true
end

-- 🧲 التثبيت في الجو
RunService.Heartbeat:Connect(function()
	if isHovering and hoverPos then
		hrp.Velocity = Vector3.zero
		hrp.CFrame = CFrame.new(hoverPos)
	end
end)

-- 🔁 حلقة القتل
function autoTS_KillLoop() -- Made function global so it can be called from toggle
	local firstRun = true

	while autoTSRunning do
		task.wait(1.5)

		-- ⛔ وقف الهجوم أثناء الصرخة
		if workspace:FindFirstChild("Debris") and workspace.Debris:FindFirstChild("Roar") then
			continue
		end

		local slot, hasAmmo = getCurrentSpearSlot()
		if hasAmmo then
			local killCount = math.random(1, 10)
			local napes = getClosestNapes(killCount)
			if #napes > 0 then
				teleportAbove(napes[1])

				-- 🕒 تأخير أول مرة فقط
				if firstRun then
					task.wait(startDelay)
					firstRun = false
				end

				GET:InvokeServer("Spears", "S_Fire", slot)
				task.wait(0.15)

				for _, nape in ipairs(napes) do
					if nape and nape.Position then
						POST:FireServer("Spears", "S_Explode", nape.Position, 0.50, 450)
					end
				end
			end
		end

		if not hoverPos then
			hoverPos = hrp.Position + Vector3.new(0, flyHeight, 0)
		end
		isHovering = true
	end
end

-- Auto mastery system
local function setupAutoMastery()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local VirtualInput = game:GetService("VirtualInputManager")
    local UserInputService = game:GetService("UserInputService")
    local player = Players.LocalPlayer
    local attackDelay = 0.15
    local walkSpeed = 3.5
    
    local function isTitanForm()
        local char = player.Character
        if not char then return false end
        local hasTotal = char:FindFirstChild("Total") ~= nil
        local hasCopy = char:FindFirstChild("Copy") ~= nil
        local has3 = char:FindFirstChild("3") ~= nil
        local hasMain = char:FindFirstChild("Main") ~= nil
        return hasTotal and not (hasCopy or has3 or hasMain)
    end
    
    local function pressMouse()
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        local screenSize = workspace.CurrentCamera.ViewportSize
        local x, y = screenSize.X / 2, screenSize.Y / 2
        VirtualInput:SendMouseButtonEvent(x, y, 0, true, game, 0)
        task.wait(0.03)
        VirtualInput:SendMouseButtonEvent(x, y, 0, false, game, 0)
    end
    
    local function getClosestTitan()
        local char = player.Character
        if not char then return nil end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        local closest, shortest = nil, math.huge
        for _, titan in ipairs(workspace.Titans:GetChildren()) do
            local hum = titan:FindFirstChild("Humanoid")
            local root = titan:FindFirstChild("HumanoidRootPart")
            if hum and root and hum.Health > 0 then
                local dist = (hrp.Position - root.Position).Magnitude
                if dist < shortest then
                    closest, shortest = root, dist
                end
            end
        end
        return closest
    end
    
    local function walkSafelyToTitan(titan)
        while titan and titan.Parent and isTitanForm() and autoMasteryActive do
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then break end
            local dir = titan.CFrame.LookVector.Unit
            local right = titan.CFrame.RightVector.Unit
            local offset = -dir * 50 + right * 15
            local targetPos = titan.Position + offset
            if (hrp.Position - targetPos).Magnitude <= 4 then
                break
            end
            local step = (targetPos - hrp.Position).Unit * walkSpeed
            hrp.CFrame = CFrame.new(hrp.Position + step, titan.Position)
            RunService.Heartbeat:Wait()
        end
    end
    
    -- Auto mastery main loop
    task.spawn(function()
        while true do
            if autoMasteryActive and isTitanForm() then
                local titan = getClosestTitan()
                if titan then
                    walkSafelyToTitan(titan)
                    task.wait(0.08)
                    if isTitanForm() then
                        for i = 1, 3 do
                            pressMouse()
                            task.wait(0.1)
                        end
                    end
                    task.wait(attackDelay)
                else
                    task.wait(0.3)
                end
            else
                task.wait(0.5)
            end
        end
    end)
end
sections.MainSection1:Toggle({
    Name = "Auto Mastery",
    Default = false,
    Callback = function(value)
        autoMasteryActive = value
        if value then
            setupAutoMastery()
        end
    end,
}, "AutoMasteryToggle")

-- Auto Skip Cutscene
local VIM = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local interface = player:FindFirstChild("PlayerGui")
    and player.PlayerGui:FindFirstChild("Interface")
local skipBtn = interface and interface:FindFirstChild("Skip")
local autoSkipEnabled = false
local mobileKillerConn  -- will hold the Heartbeat connection

local function shouldSkip()
    return skipBtn
       and skipBtn.Visible
       and skipBtn.AbsoluteSize.Magnitude > 10
end

local function pressSkipWithNavigation()
    -- Press backslash key
    VIM:SendKeyEvent(true, Enum.KeyCode.BackSlash, false, game)
    task.wait(0.5)

    -- Small delay between keys
    task.wait(0.1)

    -- Press Enter key
    VIM:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    task.wait(0.05)
    VIM:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
end

task.spawn(function()
    while true do
        if autoSkipEnabled and shouldSkip() then
            pressSkipWithNavigation()
            task.wait(1)
        end
        task.wait(0.5)
    end
end)

sections.RaidsSection1:Toggle({
    Name = "Auto Skip Cutscene",
    Default = false,
    Callback = function(state)
        autoSkipEnabled = state

        if state then
            -- Immediately destroy any existing Interface.Mobile
            local iface = player:FindFirstChild("PlayerGui")
                        and player.PlayerGui:FindFirstChild("Interface")
            if iface then
                local mobile = iface:FindFirstChild("Mobile")
                if mobile then
                    mobile:Destroy()
                end
            end

            -- Then keep destroying any new Mobile that appears
            mobileKillerConn = RunService.Heartbeat:Connect(function()
                local iface2 = player:FindFirstChild("PlayerGui")
                             and player.PlayerGui:FindFirstChild("Interface")
                if iface2 then
                    local mobile2 = iface2:FindFirstChild("Mobile")
                    if mobile2 then
                        mobile2:Destroy()
                    end
                end
            end)
        else
            -- Turn it off: stop killing Mobile
            if mobileKillerConn then
                mobileKillerConn:Disconnect()
                mobileKillerConn = nil
            end
        end
    end,
}, "AutoSkipCutscene")

--============[ Auto Open Chests ]============--
local Gui = player:WaitForChild("PlayerGui")
-- تحكم التوقلات
local autoFreeEnabled = false
local autoPremiumEnabled = false

local function canClick(btn)
    return btn and btn.Visible and btn.AbsoluteSize.Magnitude > 10
end

local function isActuallyVisible(obj)
    if not obj then return false end
    local current = obj
    while current and current ~= Gui do
        local success, result = pcall(function() return current.Visible end)
        if success and not result then
            return false
        end
        current = current.Parent
    end
    return obj.AbsoluteSize.Magnitude > 10
end

local function clickButton(btn)
    local pos = btn.AbsolutePosition
    local size = btn.AbsoluteSize
    local inset = GuiService:GetGuiInset()
    local x = pos.X + size.X / 2 + 13
    local y = pos.Y + size.Y / 2 + inset.Y
    VIM:SendMouseMoveEvent(x, y, game)
    task.wait(0.05)
    VIM:SendMouseButtonEvent(x, y, 0, true, game, 0)
    task.wait(0.05)
    VIM:SendMouseButtonEvent(x, y, 0, false, game, 0)
end

-- 🔁 Auto Free Chest
task.spawn(function()
    local interface = Gui:WaitForChild("Interface")
    local chests = interface:WaitForChild("Chests")
    local freeBtn = chests:WaitForChild("Free")
    local finishBtn = chests:WaitForChild("Finish")
    while true do
        if autoFreeEnabled and isActuallyVisible(finishBtn) then
            if canClick(freeBtn) then
                clickButton(freeBtn)
                task.wait(7)
            end
            if canClick(finishBtn) then
                clickButton(finishBtn)
                task.wait(2)
            end
            while isActuallyVisible(finishBtn) do
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end
end)

-- 🔁 Auto Premium Chest
task.spawn(function()
    local interface = Gui:WaitForChild("Interface")
    local chests = interface:WaitForChild("Chests")
    local premiumBtn = chests:WaitForChild("Premium")
    local finishBtn = chests:WaitForChild("Finish")
    while true do
        if autoPremiumEnabled and isActuallyVisible(finishBtn) then
            if canClick(premiumBtn) then
                clickButton(premiumBtn)
                task.wait(7)
            end
            if canClick(finishBtn) then
                clickButton(finishBtn)
                task.wait(2)
            end
            while isActuallyVisible(finishBtn) do
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end
end)

sections.RaidsSection1:Toggle({
    Name = "Auto Premium Chest",
    Default = false,
    Callback = function(state)
        autoPremiumEnabled = state
    end,
}, "AutoPremiumChest")

sections.RaidsSection1:Toggle({
    Name = "Auto Free Chest",
    Default = false,
    Callback = function(state)
        autoFreeEnabled = state
    end,
}, "AutoFreeChest")

-- PlaceIds
local lobbyPlaceId = 14916516914
local mainMenuPlaceId = 13379208636

-- Return to Lobby button
sections.TeleportSection1:Button({
    Name = "Return to Lobby",
    Callback = function()
        Window:Dialog({
            Title = "Teleport to Lobby",
            Description = "Are you sure you want to teleport to the lobby?",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        TeleportService:Teleport(lobbyPlaceId, player)
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Return to Main Menu button
sections.TeleportSection1:Button({
    Name = "Return to Main Menu",
    Callback = function()
        Window:Dialog({
            Title = "Teleport to Main Menu",
            Description = "Are you sure you want to teleport to the main menu?",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        TeleportService:Teleport(mainMenuPlaceId, player)
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Force Retry button
sections.TeleportSection1:Button({
    Name = "Force Retry",
    Callback = function()
        Window:Dialog({
            Title = "Force Retry",
            Description = "Are you sure you want to retry the current game/mission?",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        local success, err = pcall(function()
                            retryRemote:InvokeServer("Functions", "Retry", "Add")
                        end)
                        if success then
                            -- Success - no action needed
                        else
                            warn(".")
                        end
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local player = Players.LocalPlayer

local webhookURL = ""
local sendWebhook = false
local showUsername = true
local pingOnSpecial = false -- New toggle for pinging on serum/mythic
local thumbnailURL = "https://cdn.discordapp.com/attachments/1379045906539872307/1382205089917440010/Black_and_White_Modern_Bold_Script_Logo_1.png?ex=684a4e4d&is=6848fccd&hm=487a99ea8096f0da51b375dfb5976aca0807753620c332a1922435dc73791091&"

-- Initialize stats storage
local statsData = {
    totalGold = 0,
    totalXP = 0,
    totalGems = 0,
    totalBPXP = 0,
    totalDamage = 0,
    totalKills = 0,
    totalCrits = 0,
    totalCommonPerks = 0,
    totalRarePerks = 0,
    totalEpicPerks = 0,
    totalLegendaryPerks = 0,
    totalPrestigeScrolls = 0,
    totalMythicalPerks = 0,
    totalSerum = 0,
    missions = 0,
    lastUpdated = ""
}

-- Function to load saved stats with enhanced error handling
local function loadStats()
    -- Debug print removed
    
    -- Ensure HttpService is available
    local HttpService = game:GetService("HttpService")
    if not HttpService then
        print("[ERROR] loadStats: HttpService is not available!")
        return false
    end
    
    -- Check if file exists
    local fileExists = pcall(function() return isfile("LunarZ_Stats.json") end)
    if not fileExists then
        -- Debug print removed
        saveStats()
        return false
    end
    
    -- Read and parse file
    local success, result = pcall(function()
        local content = readfile("LunarZ_Stats.json")
        if not content or content == "" then
            print("[ERROR] loadStats: Stats file is empty")
            return nil
        end
        -- Debug print removed
        return HttpService:JSONDecode(content)
    end)
    
    -- Process results
    if success and result then
        -- Debug print removed
        local loadedCount = 0
        for key, value in pairs(result) do
            if statsData[key] ~= nil then
                statsData[key] = value
                loadedCount = loadedCount + 1
                -- Debug print removed
            end
        end
        -- Debug print removed: Stats loaded successfully
        return true
    else
        print("[ERROR] loadStats: Failed to load stats: " .. tostring(result))
        -- Create a new stats file if parsing failed
        saveStats()
        return false
    end
end

-- Function to save stats with enhanced error handling
local function saveStats()
    -- Debug print removed
    
    -- Ensure HttpService is available
    local HttpService = game:GetService("HttpService")
    if not HttpService then
        print("[ERROR] saveStats: HttpService is not available!")
        return false
    end
    
    -- Encode and save data
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(statsData)
        if not encoded or encoded == "" then
            print("[ERROR] saveStats: Failed to encode stats data")
            return
        end
        -- Debug print removed
        writefile("LunarZ_Stats.json", encoded)
    end)
    
    -- Check result
    if success then
        print("[INFO] Stats saved successfully!")
        return true
    else
        print("[ERROR] saveStats: Failed to save stats: " .. tostring(err))
        return false
    end
end

-- Try to load saved stats on script start
pcall(loadStats)

-- Toggle to control whether webhook should be sent
sections.WebhookSection1:Toggle({
    Name = "Notify Webhook",
    Default = false,
    Callback = function(Value)
        sendWebhook = Value
    end,
}, "SendWebhookToggle")

-- Toggle to display Roblox username
sections.WebhookSection1:Toggle({
    Name = "Display Roblox Username",
    Default = true,
    Callback = function(Value)
        showUsername = Value
    end,
}, "DisplayUsernameToggle")

-- NEW: Toggle for pinging on serum/mythic drops
sections.WebhookSection1:Toggle({
    Name = "Ping on Serum/Mythic",
    Default = false,
    Callback = function(Value)
        pingOnSpecial = Value
    end,
}, "PingSpecialToggle")

-- Input for the webhook URL
sections.WebhookSection1:Input({
    Name = "Webhook",
    Placeholder = "https://discord.com/api/webhooks/...",
    AcceptedCharacters = "All",
    Callback = function(Value)
        webhookURL = Value
    end,
    onChanged = function(Value)
        print("Webhook URL is now " .. Value)
    end,
}, "WebhookInput")

-- Test webhook button
sections.WebhookSection1:Button({
    Name = "Test Webhook",
    Callback = function()
        if webhookURL == "" then
            Window:Dialog({
                Title = "Test Webhook",
                Description = "Please enter a webhook URL before testing.",
                Buttons = {
                    {
                        Name = "OK"
                    }
                }
            })
            return
        end
        
        Window:Dialog({
            Title = "Test Webhook",
            Description = "Send a test message to your Discord webhook?",
            Buttons = {
                {
                    Name = "Send Test",
                    Callback = function()
                        local timeString = os.date("%d-%b-%Y %I:%M %p")
                        
                        -- Updated test embed to match new format
                        local testEmbed = {
                            title = "LunarZ Rewards Logger",
                            description = "**User:** " .. (showUsername and player.Name or "Disabled") .. "\n\n**Totals:**\nLevel: Test\nGold: Test\nGems: Test\n\n**Stats:**\nTime Taken: Test\nDamage Dealt: Test\nTitan Kills: Test\nCritical Hits: Test\n\n**Rewards:**\nGold: Test\nXP: Test\nGems: Test\n\n**Drops:**\nBP XP: Test\nCommon Perk: Test\nRare Perk: Test\nLegendary Perk: Test\n\n**Special Rewards:**\nSerum: Test",
                            thumbnail = { url = thumbnailURL },
                            color = 9936031	, -- Blue color
                            footer = { text = "Test sent at: " .. timeString }
                        }

                        local testData = {
                            embeds = {testEmbed}
                        }

                        local success, response = pcall(function()
                            return request({
                                Url = webhookURL,
                                Method = "POST",
                                Headers = {["Content-Type"] = "application/json"},
                                Body = HttpService:JSONEncode(testData)
                            })
                        end)
                        
                        if success then
                            print("Test webhook sent successfully!")
                            Window:Dialog({
                                Title = "Test Webhook",
                                Description = "Test webhook sent successfully! Check your Discord channel.",
                                Buttons = {
                                    {
                                        Name = "OK"
                                    }
                                }
                            })
                        else
                            print("Failed to send test webhook: " .. tostring(response))
                            Window:Dialog({
                                Title = "Test Webhook Error",
                                Description = "Failed to send test webhook. Please check your webhook URL and try again.",
                                Buttons = {
                                    {
                                        Name = "OK"
                                    }
                                }
                            })
                        end
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Check visibility of GUI
local function isActuallyVisible(instance)
    if not instance then return false end
    if not instance:IsDescendantOf(player.PlayerGui) then return false end
    while instance and instance ~= player.PlayerGui do
        if instance:IsA("GuiObject") and not instance.Visible then
            return false
        end
        instance = instance.Parent
    end
    return true
end

-- Get Retry button
local function getRetryButton()
    local interface = player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local rewardsMain = rewards and rewards:FindFirstChild("Main")
    local retryBtn = rewardsMain
        and rewardsMain:FindFirstChild("Info")
        and rewardsMain.Info:FindFirstChild("Main")
        and rewardsMain.Info.Main:FindFirstChild("Buttons")
        and rewardsMain.Info.Main.Buttons:FindFirstChild("Retry")
    return retryBtn
end

-- Get GUI text value
local function getText(path)
    local node = player:FindFirstChild("PlayerGui")
    for _, part in ipairs(string.split(path, ".")) do
        if node then
            node = node:FindFirstChild(part)
        end
    end
    return node and node.Text or "0"
end

-- Get items and stats panels
local function getItems()
    local gui = player:FindFirstChild("PlayerGui")
    local interface = gui and gui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local main = rewards and rewards:FindFirstChild("Main")
    local info = main and main:FindFirstChild("Info")
    local infoMain = info and info:FindFirstChild("Main")
    local items = infoMain and infoMain:FindFirstChild("Items")
    local stats = infoMain and infoMain:FindFirstChild("Stats")
    return items, stats
end

local lastMissionTime = nil

-- Setup Stats Tab UI
sections.StatsSection1:Header({
    Name = "Earnings"
})

-- Gold Label
local goldLabel = sections.StatsSection1:Label({
    Text = "Gold: " .. tostring(statsData.totalGold)
})

-- XP Label
local xpLabel = sections.StatsSection1:Label({
    Text = "XP: " .. tostring(statsData.totalXP)
})

-- Gems Label
local gemsLabel = sections.StatsSection1:Label({
    Text = "Gems: " .. tostring(statsData.totalGems)
})

-- BP XP Label
local bpXPLabel = sections.StatsSection1:Label({
    Text = "BP XP: " .. tostring(statsData.totalBPXP)
})

sections.StatsSection1:Header({
    Name = "Performance"
})

-- Damage Label
local damageLabel = sections.StatsSection1:Label({
    Text = "Total Damage: " .. tostring(statsData.totalDamage)
})

-- Kills Label
local killsLabel = sections.StatsSection1:Label({
    Text = "Titans Killed: " .. tostring(statsData.totalKills)
})

-- Crits Label
local critsLabel = sections.StatsSection1:Label({
    Text = "Critical Hits: " .. tostring(statsData.totalCrits)
})

-- Missions Label
local missionsLabel = sections.StatsSection1:Label({
    Text = "Missions/Raids Completed: " .. tostring(statsData.missions)
})

sections.StatsSection2:Header({
    Name = "Perks & Special Items"
})

-- Common Perks Label
local commonLabel = sections.StatsSection2:Label({
    Text = "Common Perks: " .. tostring(statsData.totalCommonPerks)
})

-- Rare Perks Label
local rareLabel = sections.StatsSection2:Label({
    Text = "Rare Perks: " .. tostring(statsData.totalRarePerks)
})

-- Epic Perks Label
local epicLabel = sections.StatsSection2:Label({
    Text = "Epic Perks: " .. tostring(statsData.totalEpicPerks)
})

-- Legendary Perks Label
local legendaryLabel = sections.StatsSection2:Label({
    Text = "Legendary Perks: " .. tostring(statsData.totalLegendaryPerks)
})

-- Prestige Scrolls Label
local prestigeLabel = sections.StatsSection2:Label({
    Text = "Prestige Scrolls: " .. tostring(statsData.totalPrestigeScrolls)
})

-- Mythical Perks Label
local mythicalLabel = sections.StatsSection2:Label({
    Text = "Mythical Perks: " .. tostring(statsData.totalMythicalPerks)
})

-- Serum Label
local serumLabel = sections.StatsSection2:Label({
    Text = "Serum: " .. tostring(statsData.totalSerum)
})

-- Last Updated Label
local lastUpdatedLabel = sections.StatsSection2:Label({
    Text = "Last Updated: " .. (statsData.lastUpdated ~= "" and statsData.lastUpdated or "Never")
})

-- Reset Stats Button
sections.StatsSection2:Button({
    Name = "Reset Stats",
    Callback = function()
        Window:Dialog({
            Title = "Reset Stats",
            Description = "Are you sure you want to reset all stats? This cannot be undone.",
            Buttons = {
                {
                    Name = "Confirm",
                    Callback = function()
                        -- Reset all stats to 0
                        for key, _ in pairs(statsData) do
                            if key ~= "lastUpdated" then
                                statsData[key] = 0
                            end
                        end
                        statsData.lastUpdated = os.date("%d-%b-%Y %I:%M %p")
                        
                        -- Update UI using the updateStatsUI function with null checks
                        updateStatsUI()
                        
                        -- Save to file
                        saveStats()
                        
                        Window:Notify({
                            Title = "Stats Reset",
                            Description = "All stats have been reset to zero.",
                            Lifetime = 5
                        })
                    end,
                },
                {
                    Name = "Cancel"
                }
            }
        })
    end,
})

-- Function to update UI with current stats
local function updateStatsUI()
    -- Add null checks and type verification for each UI element
    if goldLabel and typeof(goldLabel.SetText) == "function" then
        goldLabel:SetText("Gold: " .. tostring(statsData.totalGold))
    end
    
    if xpLabel and typeof(xpLabel.SetText) == "function" then
        xpLabel:SetText("XP: " .. tostring(statsData.totalXP))
    end
    
    if gemsLabel and typeof(gemsLabel.SetText) == "function" then
        gemsLabel:SetText("Gems: " .. tostring(statsData.totalGems))
    end
    
    if bpXPLabel and typeof(bpXPLabel.SetText) == "function" then
        bpXPLabel:SetText("BP XP: " .. tostring(statsData.totalBPXP))
    end
    
    if damageLabel and typeof(damageLabel.SetText) == "function" then
        damageLabel:SetText("Total Damage: " .. tostring(statsData.totalDamage))
    end
    
    if killsLabel and typeof(killsLabel.SetText) == "function" then
        killsLabel:SetText("Titans Killed: " .. tostring(statsData.totalKills))
    end
    
    if critsLabel and typeof(critsLabel.SetText) == "function" then
        critsLabel:SetText("Critical Hits: " .. tostring(statsData.totalCrits))
    end
    
    if missionsLabel and typeof(missionsLabel.SetText) == "function" then
        missionsLabel:SetText("Missions/Raids Completed: " .. tostring(statsData.missions))
    end
    
    if commonLabel and typeof(commonLabel.SetText) == "function" then
        commonLabel:SetText("Common Perks: " .. tostring(statsData.totalCommonPerks))
    end
    
    if rareLabel and typeof(rareLabel.SetText) == "function" then
        rareLabel:SetText("Rare Perks: " .. tostring(statsData.totalRarePerks))
    end
    
    if epicLabel and typeof(epicLabel.SetText) == "function" then
        epicLabel:SetText("Epic Perks: " .. tostring(statsData.totalEpicPerks))
    end
    
    if legendaryLabel and typeof(legendaryLabel.SetText) == "function" then
        legendaryLabel:SetText("Legendary Perks: " .. tostring(statsData.totalLegendaryPerks))
    end
    
    if prestigeLabel and typeof(prestigeLabel.SetText) == "function" then
        prestigeLabel:SetText("Prestige Scrolls: " .. tostring(statsData.totalPrestigeScrolls))
    end
    
    if mythicalLabel and typeof(mythicalLabel.SetText) == "function" then
        mythicalLabel:SetText("Mythical Perks: " .. tostring(statsData.totalMythicalPerks))
    end
    
    if serumLabel and typeof(serumLabel.SetText) == "function" then
        serumLabel:SetText("Serum: " .. tostring(statsData.totalSerum))
    end
    
    if lastUpdatedLabel and typeof(lastUpdatedLabel.SetText) == "function" then
        lastUpdatedLabel:SetText("Last Updated: " .. statsData.lastUpdated)
    end
end

-- Function to safely convert string to number
local function safeToNumber(str)
    if not str or str == "" then return 0 end
    
    -- Remove any non-digit characters except decimal point
    local cleanStr = str:gsub("[^%d%.]", "")
    
    -- Handle potential errors
    local success, result = pcall(function()
        return tonumber(cleanStr)
    end)
    
    if not success or not result then
        -- Debug print removed
        return 0
    end
    
    return result
end

-- Add a manual update button
sections.StatsSection2:Button({
    Name = "Force Update Stats",
    Callback = function()
        local success = updateStatsFromRewards()
        if success then
            Window:Notify({
                Title = "Stats Updated",
                Description = "Stats have been updated from the current rewards screen.",
                Lifetime = 5
            })
        else
            Window:Notify({
                Title = "Update Failed",
                Description = "No rewards screen detected or no new data found.",
                Lifetime = 5
            })
        end
    end,
})

-- Function to update stats from rewards screen with improved error handling
local function updateStatsFromRewards()
    -- Debug print removed
    
    -- Check if rewards screen is visible
    local retryBtn = getRetryButton()
    local items, stats = getItems()
    
    if not isActuallyVisible(retryBtn) then
        -- Debug print removed
        return false
    end
    
    if not stats then
        -- Debug print removed
        return false
    end
    
    -- Get mission time to check if this is a new mission
    local currentTime = getText("Interface.Rewards.Main.Info.Main.Stats.Time_Taken.Amount")
    -- Debug print removed
    
    if currentTime == "0" or currentTime == lastMissionTime then
        -- Debug print removed
        return false
    end
    
    -- Debug print removed: New mission detected
    lastMissionTime = currentTime

    -- Get all reward values with error checking - Updated perk names
    local gold = getText("Interface.Rewards.Main.Info.Main.Items.Gold.Main.Inner.Quantity")
    local xp = getText("Interface.Rewards.Main.Info.Main.Items.XP.Main.Inner.Quantity")
    local bp_xp = getText("Interface.Rewards.Main.Info.Main.Items.BP_XP.Main.Inner.Quantity")
    local gems = getText("Interface.Rewards.Main.Info.Main.Items.Gems.Main.Inner.Quantity")
    local serum = getText("Interface.Rewards.Main.Info.Main.Items.Serum.Main.Inner.Quantity")
    local common = getText("Interface.Rewards.Main.Info.Main.Items.Common_Perk.Main.Inner.Quantity")
    local rare = getText("Interface.Rewards.Main.Info.Main.Items.Rare_Perk.Main.Inner.Quantity")
    local epic = getText("Interface.Rewards.Main.Info.Main.Items.Epic_Perk.Main.Inner.Quantity")
    local legendary = getText("Interface.Rewards.Main.Info.Main.Items.Legendary_Perk.Main.Inner.Quantity")
    local prestige = getText("Interface.Rewards.Main.Info.Main.Items.Prestige_Scroll.Main.Inner.Quantity")
    local mythical = getText("Interface.Rewards.Main.Info.Main.Items.Mythical_Perk.Main.Inner.Quantity")

    local damage = getText("Interface.Rewards.Main.Info.Main.Stats.Damage_Dealt.Amount")
    local kills = getText("Interface.Rewards.Main.Info.Main.Stats.Titans_Killed.Amount")
    local crits = getText("Interface.Rewards.Main.Info.Main.Stats.Critical_Hits.Amount")

    local timeString = os.date("%d-%b-%Y %I:%M %p")
    
    -- Debug prints removed
    
    -- Update stats data with new values
    local oldGold = statsData.totalGold
    statsData.totalGold = statsData.totalGold + safeToNumber(gold)
    statsData.totalXP = statsData.totalXP + safeToNumber(xp)
    statsData.totalGems = statsData.totalGems + safeToNumber(gems)
    statsData.totalBPXP = statsData.totalBPXP + safeToNumber(bp_xp)
    statsData.totalDamage = statsData.totalDamage + safeToNumber(damage)
    statsData.totalKills = statsData.totalKills + safeToNumber(kills)
    statsData.totalCrits = statsData.totalCrits + safeToNumber(crits)
    statsData.totalCommonPerks = statsData.totalCommonPerks + safeToNumber(common)
    statsData.totalRarePerks = statsData.totalRarePerks + safeToNumber(rare)
    statsData.totalEpicPerks = statsData.totalEpicPerks + safeToNumber(epic)
    statsData.totalLegendaryPerks = statsData.totalLegendaryPerks + safeToNumber(legendary)
    statsData.totalPrestigeScrolls = statsData.totalPrestigeScrolls + safeToNumber(prestige)
    statsData.totalMythicalPerks = statsData.totalMythicalPerks + safeToNumber(mythical)
    statsData.totalSerum = statsData.totalSerum + safeToNumber(serum)
    statsData.missions = statsData.missions + 1
    statsData.lastUpdated = timeString
    
    -- Verify that stats were actually updated
    if statsData.totalGold == oldGold then
        -- Debug print removed: Stats don't appear to have changed warning
    end
    
    -- Update UI
    updateStatsUI()
    
    -- Save stats to file
    local saveSuccess = saveStats()
    if not saveSuccess then
        print("[ERROR] updateStatsFromRewards: Failed to save stats after update")
    end
    
    -- Send webhook with rewards data if enabled
    if sendWebhook and webhookURL ~= "" then
        -- Check if we should ping for special items (including legendary perks)
        local shouldPing = pingOnSpecial and ((tonumber(serum) or 0) > 0 or (tonumber(mythical) or 0) > 0 or (tonumber(legendary) or 0) > 0)
        
        -- Build the description with updated perk information
        local description = string.format(
            "**User:** %s\n\n" ..
            "**Totals:**\n" ..
            "Level: %d\n" ..
            "Gold: %s\n" ..
            "Gems: %s\n\n" ..
            "**Stats:**\n" ..
            "%s Time Taken\n" ..
            "%s Damage Dealt\n" ..
            "%s Titan Kills\n" ..
            "%s Critical Hits\n\n" ..
            "**Rewards:**\n" ..
            "%s Gold\n" ..
            "%s XP\n" ..
            "%s Gems\n\n" ..
            "**Drops:**\n" ..
            "%s BP XP\n" ..
            "%s Common Perk\n" ..
            "%s Rare Perk\n" ..
            "%s Epic Perk\n" ..
            "%s Legendary Perk\n\n" ..
            "**Special Rewards:**\n" ..
            "%s Serum\n" ..
            "%s Mythical Perk",
            showUsername and player.Name or "Disabled",
            statsData.missions,
            tostring(statsData.totalGold),
            tostring(statsData.totalGems),
            currentTime,
            damage,
            kills,
            crits,
            gold,
            xp,
            gems,
            bp_xp,
            common,
            rare,
            epic,
            legendary,
            serum,
            mythical
        )

        local embed = {
            title = "LunarZ Rewards Logger",
            description = description,
            thumbnail = { url = thumbnailURL },
            color = 9936031	, -- Blue color to match the image
            footer = { text = "Sent at: " .. timeString }
        }

        local data = {
            content = shouldPing and "@everyone" or nil,
            embeds = {embed}
        }

        local success, response = pcall(function()
            return request({
                Url = webhookURL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode(data)
            })
        end)
        
        if success then
            -- Debug print removed: Webhook sent successfully
        else
            -- Debug print removed: Failed to send webhook
        end
    end
    
    -- Debug print removed: Stats updated successfully
    return true
end

-- Stats update loop with improved error handling
task.spawn(function()
    -- Debug print removed: Starting stats tracking loop
    local consecutiveErrors = 0
    
    while true do
        local success, err = pcall(function()
            local statsUpdated = updateStatsFromRewards()
            if statsUpdated then
                consecutiveErrors = 0 -- Reset error counter on success
                -- Debug print removed: Stats successfully updated from rewards
            end
        end)
        
        if not success then
            consecutiveErrors = consecutiveErrors + 1
            print("[ERROR] Error in stats update loop: " .. tostring(err))
            
            -- If we get too many consecutive errors, slow down the loop
            if consecutiveErrors > 5 then
                print("[WARNING] Multiple consecutive errors in stats tracking. Slowing down update frequency.")
                task.wait(5) -- Wait longer between attempts after multiple failures
            else
                task.wait(1)
            end
        else
            task.wait(1)
        end
    end
end)

sections.VisualSection1:Toggle({
    Name = "Titan ESP",
    Default = false,
    Callback = function(Value)
        if Value then
            local titansFolder = game.Workspace:FindFirstChild("Titans")
            if not titansFolder then
                Fluent:Notify({
                    Title = "Error",
                    Content = "Titans folder not found. Are you in a mission?",
                    Duration = 3
                })
                return
            end
            
            for _, titan in pairs(titansFolder:GetChildren()) do
                -- Check if highlight already exists
                if not titan:FindFirstChild("Highlight") then
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = titan
                    highlight.Archivable = true
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Enabled = true
                    highlight.FillColor = Color3.fromRGB(255, 0, 4)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                end
            end
            
            -- Connect to ChildAdded to highlight new titans
            game.Workspace.Titans.ChildAdded:Connect(function(titan)
                if sections.MainSection1.TitanESP then -- Updated reference
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = titan
                    highlight.Archivable = true
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Enabled = true
                    highlight.FillColor = Color3.fromRGB(255, 0, 4)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                end
            end)
        else
            -- Remove highlights when toggled off
            local titansFolder = game.Workspace:FindFirstChild("Titans")
            if titansFolder then
                for _, titan in pairs(titansFolder:GetChildren()) do
                    local highlight = titan:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
    end,
}, "TitanESP")

-- ESP Color Picker
sections.VisualSection1:Colorpicker({
    Name = "ESP Color",
    Default = Color3.fromRGB(255, 0, 4),
    Callback = function(Value)
        local titansFolder = game.Workspace:FindFirstChild("Titans")
        if titansFolder then
            for _, titan in pairs(titansFolder:GetChildren()) do
                local highlight = titan:FindFirstChild("Highlight")
                if highlight then
                    highlight.FillColor = Value
                end
            end
        end
    end,
}, "ESPColor")

-- Optimize Game Toggle
sections.VisualSection1:Toggle({
    Name = "Optimize Game",
    Default = false,
    Callback = function(Value)
        if Value then
            local decalsyeeted = true
            local g = game
            local w = g.Workspace
            local l = g.Lighting
            local t = w.Terrain
            
            t.WaterWaveSize = 0
            t.WaterWaveSpeed = 0
            t.WaterReflectance = 0
            t.WaterTransparency = 0
            l.GlobalShadows = false
            l.FogEnd = 9e9
            l.Brightness = 0
            settings().Rendering.QualityLevel = "Level01"
            
            for i, v in pairs(g:GetDescendants()) do
                if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
                    v.Transparency = 1
                elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                    v.Lifetime = NumberRange.new(0)
                elseif v:IsA("Explosion") then
                    v.BlastPressure = 1
                    v.BlastRadius = 1
                elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
                    v.Enabled = false
                elseif v:IsA("MeshPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                    v.TextureID = 10385902758728957
                end
            end
            
            for i, e in pairs(l:GetChildren()) do
                if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
                    e.Enabled = false
                end
            end
        end
    end,
}, "OptimizeGame")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local hiddenFolder = ReplicatedStorage:FindFirstChild("aristo_deletemap")
if not hiddenFolder then
    hiddenFolder = Instance.new("Folder")
    hiddenFolder.Name = "aristo_deletemap"
    hiddenFolder.Parent = ReplicatedStorage
end

sections.VisualSection1:Toggle({
    Name = "Delete Map",
    Default = false,
    Callback = function(state)
        if state then
            -- إخفاء Climbable ونضع مجلد وهمي بنفس الاسم
            local climbable = workspace:FindFirstChild("Climbable")
            if climbable then
                -- مجلد وهمي لتفادي مشكلة WaitForChild
                local fakeClimbable = Instance.new("Folder")
                fakeClimbable.Name = "Climbable"
                fakeClimbable.Parent = workspace
                climbable.Parent = hiddenFolder
            else
                -- Climbable not found
            end
            -- إخفاء العناصر غير المهمة داخل Unclimbable
            local unclimbable = workspace:FindFirstChild("Unclimbable")
            if unclimbable then
                for _, child in ipairs(unclimbable:GetChildren()) do
                    if child.Name ~= "Reloads" and child.Name ~= "Objective" and child.Name ~= "Cutscene" then
                        pcall(function()
                            child.Parent = hiddenFolder
                        end)
                    end
                end
            else
                -- Unclimbable not found
            end
            -- تعطيل Collider داخل Objective
            local objective = unclimbable and unclimbable:FindFirstChild("Objective")
            if objective then
                local guard = objective:FindFirstChild("Guard")
                if guard then
                    local collider = guard:FindFirstChild("Collider")
                    if collider and collider:IsA("BasePart") then
                        collider.CanTouch = false
                        collider.CanCollide = false
                        collider.Transparency = 1
                    end
                end
            end
        else
            -- Toggle disabled
        end
    end,
}, "del")

MacLib:SetFolder("Maclib")
tabs.Settings:InsertConfigSection("Left")

Window.onUnloaded(function()
	print("LunarZ Loaded!")
end)

tabs.Main:Select()
MacLib:LoadAutoLoadConfig()
